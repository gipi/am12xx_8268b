/**
 * \file  nand_scan.c
 * \brief  Scan the zone tables in flash
 *
 * This module search the zone tables in flash firstly. If cannot be found or\n
 * checksum error, rebuild the zone tables.
 *
 *  Copyright (c) 2007 Actions Semiconductor Co., Ltd.
 *
 * \author David
 *
 * \date 2007.07
 *
 * \version 0.0.1
 */
#define	ON_NAND_FLASH
#include "nand_flash_driver_type.h"
#if (!defined(__KERNEL__)) 
#include "adfu.h"
#else
//#include <adfu.h>
#endif
#include "nand_regs.h"
#include "sys_buf_def.h"

extern INT32U  PHY_PageRead(struct PhysicOpParameter *NandOpPar);
extern INT32U  PHY_PageWrite(struct PhysicOpParameter *NandOpPar);
extern INT32U  PHY_EraseSuperBlk(struct PhysicOpParameter *PhyOpPar);
extern INT32U  PHY_CopyNandPage(struct PhysicOpParameter *NandOpSrcPar, struct PhysicOpParameter *NandOpDstPar);
extern INT32U  PHY_SyncNandOperation(INT32U BankNum);
extern INT32U FTL_CalPhyOpPar(struct PhysicOpParameter * PhyOpPar, INT32U ZoneNum, INT32U SupBlkNum, INT32U PageNum);
#define dump_mem
/* defines */

#define DEBUG
#define DBG_DUMP_DIE_INFO
//#define DBG_DUMP_ZONE_TBLS

//#define DBG_ALWAYS_REBUILD_ZONETBLS

//#define DBG_TEST_FILL_FLASH

//#define CONFIG_SCAN_REBUILD_PMTBL

//#define DBG_TEST_PHY

#define BREC_SECTOR_NUM   (NAND_BREC_SIZE/512)
#ifdef DEBUG
/* debug level defines */
#define DBL_ERR         0x1
#define DBL_WARNING     0x2
#define DBL_INFO        0x3
#define DBL_LOG         0x4

#define DEBUG_LEVEL		DBL_LOG

#define DMSG(DebugLevel, fmt, args...)                 \
    do {                                                                \
        if (DebugLevel <= DEBUG_LEVEL) {                             \
            INIT_DBG(fmt, ##args);                                         \
        }                                                               \
    } while (0)

#define DASSERT(x) ((x) ? ((void) 0) : printf("[SCAN] Assertion failure at file %s, line %u\n", \
		__FILE__, __LINE__))

#else	/* DEBUG */

#define DMSG(DebugLevel, fmt, args...)
#define DASSERT(x)

#endif	/* DEBUG */


/* error code defines */
#define SCAN_LAYER_ERROR        (0x8000)
#define SCAN_ERR_NO_MEM         (SCAN_LAYER_ERROR | 0x1)
#define SCAN_ERR_TRY_AGAIN      (SCAN_LAYER_ERROR | 0x2)

/* const defines */

#define SECTORS_PER_PHY_BLK           (SECTOR_NUM_PER_SINGLE_PAGE * PAGE_CNT_PER_PHY_BLK)
#define SECTORS_TO_BLOCKS(sectors)    ((sectors + SECTORS_PER_PHY_BLK - 1) / SECTORS_PER_PHY_BLK)
#define MBRC_MAX_UNITS          4
#define BREC_MAX_UNITS          4

static INT32S DIE_FIRST_SUBLK_NUM = 0;     /* start physical block of die */

#define MAX_ZONETBL_AREA_BLOCK  48   /* zone table area is at the first 48 blocks in die */
///#define TABLE_CHKSUM_OFFSET		2046


/*#if  (User_Data_2Byte==1)
#define SECTOR_BITMAP_BBF \
	(MULTI_PLANE_SUPPORT ? GenSectorBitMap(0x3, 0x3) : GenSectorBitMap(0x3, 0x0))
#define SECTOR_BITMAP_SPAREDATA GenSectorBitMap(0xf, 0x0)
#else	
#define SECTOR_BITMAP_BBF \
	(MULTI_PLANE_SUPPORT ? GenSectorBitMap(0x1, 0x1) : GenSectorBitMap(0x1, 0x0))	
#define SECTOR_BITMAP_SPAREDATA GenSectorBitMap(0x3, 0x0)
#endif
*/
#define SECTOR_BITMAP_ZONETBL   GenSectorBitMap(0xf, 0x0)
#define SECTOR_BITMAP_DIRTYFLAG GenSectorBitMap(0x1, 0x0)
#define SECTOR_BITMAP_PMTBL     GenSectorBitMap(0xf, 0x0)
#define BITMAP_ZONETBL_4K   GenSectorBitMap(0xFF, 0x0)

#define SECTOR_BITMAP_FULLPLANE	FULL_BITMAP_OF_SUPER_PAGE

/* Bad block falg postion (FIXME: also defined in nand_proble.c)*/
/* Bad block falg postion (FIXME: also defined in nand_proble.c)*/
#define BBF_POS_PAGE0           (0x0)
#define BBF_POS_PAGE0_1           (0x1)
#define BBF_POS_LASTPAGE0       (0x2)
#define BBF_POS_LASTPAGE0_1       (0x3)

/* page offset in zone table group defines */
#define ZONETBL_PAGE_CNT        (4)    /* 4 pages per zone table group, must be 2^n */
#define PAGE_OFFSET_ZONETBL		(0)    /* the page offset of zone table in zone table group */
#define PAGE_OFFSET_LOGBLKTBL   (LOGTBL_OFFSET)    /* the page offset of log block table in zone table group */
#define PAGE_OFFSET_DIRTYFLAG   (DIRTYFlag_OFFSET)    /* the page offset of dirty flag page in zone table group */

/* page state in spare area defines */
//define nand_flash_drivers_types.h

/* block state in PhyBlkArray */
#define BLOCK_STATE_NIL         (0xfffd)
#define BLOCK_STATE_BAD         (0xfffe)
#define BLOCK_STATE_FREE        (0xffff)

/* block type in spare area */
#define BLOCK_TYPE_SPECIAL      (0x8000)
#define BLOCK_TYPE_MASK         (0x3ff)
#define BLOCK_TYPE_ZONETBL      (0xaa)
#define BLOCK_TYPE_BREC         (0xbb)

#define GetBlockType(LogicalBlkInfo)     ((LogicalBlkInfo) & 0x3ff)
#define GetLogBlockNum(LogicalBlkInfo)   ((LogicalBlkInfo) & 0x3ff)
#define GetZoneTblNum(LogicalBlkInfo)    (((LogicalBlkInfo) >> 10) & 0x0f)

/* zone number in flash */
#define ZONENO_IN_FLASH(DieNo, ZoneInDie)    ((DieNo) * ZONENUM_PER_DIE + (ZoneInDie))

#define SEQ_CMP(a, b)           ((INT8S)(( INT8S)(a) - (INT8S)(b)))
#define SEQ_BIGGER(a, b)        ((SEQ_CMP((a), (b))) > 0 ? 1 : 0)               /* return 1: seq a > seq b */
#define SEQ_SMALLER(a, b)       ((SEQ_CMP((a), (b))) < 0 ? 1 : 0)               /* return 1: seq a < seq b */
#define SEQ_EQUAL(a, b)         ((SEQ_CMP((a), (b))) == 0 ? 1 : 0)              /* return 1: seq a = seq b */
#define SEQ_NEXT(a)             ((INT8U)((INT8U)(a)+1)) /* the next seq number */

/* globals */

/* externals */

extern struct NandDev NandDevInfo;

extern INT32U  INIT_ScanNandStorage(void);
/* locals */

/**
* \brief  scan zone information for rebuilding
*/
struct ScanZoneInfo
{
	INT16S DataBlkCnt;           /**< The data block count that zone has */
	INT16S LogBlkCnt;			/**< The log block count that zone has */
	INT16S FreeBlkCnt;			/**< The free block count that zone has */
	INT16S FreeBlkInex;          /**< The current free block index in free block table */
#if _NEW_ZONE_TBL_==0x01
	INT32S                   ZoneTbl[BLK_NUM_PER_ZONE];   /**< The zone table */
#else
	INT16S                   ZoneTbl[BLK_NUM_PER_ZONE];   /**< The zone table */
#endif
	struct LogBlkTblType    LogBlkTbl[MAX_LOG_BLK_NUM];  /**< The log block table */
};

/**
* \brief  scan die information for rebuilding
*/
struct ScanDieInfo
{
	INT8U   DieNo;              /**< The die number in flash  */
	INT16U  BadBlkCnt;		    /**< Bad block count */
	INT16U  FreeBlkCnt;		    /**< Free block count */
	INT16U  LastFreeBlk;	    /**< The last used free block index in physical block array */

	INT8U   ValidZoneTblFlag[MAX_ZONE_NUM_IN_DIE];       /**< The valid flag of zone table */

	INT16U	*PhyBlkArray;                                /**< Physical block infomation array */
	struct ScanZoneInfo   *ZoneInfos;                    /**< The ScanZoneInfo arrays of this die */
};

static struct ScanDieInfo DieInfo;
INT8U *GPageBuf            = NULL;
static INT8U *GPMTblBuf           = NULL;

static INT32U TOTAL_BANKS         = 0;
static INT32U DIENUM_IN_FLASH     = 0;
static INT32U ZONENUM_PER_DIE     = 0;
static INT32U SUBLK_PER_DIE       = 0;
static INT32U MULTI_PLANE_SUPPORT = 0;
static INT32U PAGES_PER_SUBLK     = 0;

/* forward declarations */

static INT32U ScanSearchZoneTbls(struct ScanDieInfo *sdi);
static INT32U ScanRebuildZoneTbls(struct ScanDieInfo *sdi);
static INT32U ScanReadZoneTbl(struct ScanDieInfo *sdi, INT32U zone);
static void ScanFreeMemory(struct ScanDieInfo *sdi);
static INT32S ScanInitMemory(struct ScanDieInfo *sdi);



/**
 * \brief   Read a page of super block
 *
 * This routine reads one page of super block.
 *
 * \param[in]  DieNo The die number that block in
 * \param[in]  SuBlkInDie The super block number in die
 * \param[in]  PageInSuBlk The page number in SuBlk
 * \param[in]  SectorBitmapInPage The sector bitmap of page
 * \param[out] DBuf The buffer for data
 * \param[out] pSData The pointer of NandSpareData
 *
 * \return  the search result
 *  - TRUE  Succeeded to read
 *  - FALSE  Failed to read
 *  - FALSE|ECCERROR  the ecc error;
 *  - FALSE|ADDRERROR  the address is invalid;
 */
static INT32U SuBlkPageRead(INT32U DieNo, INT32U SuBlkInDie, INT32U PageInSuBlk, INT32U SectorBitmapInPage,
	INT8U *DBuf, struct NandSpareData *pSData)
{
	struct PhysicOpParameter param;
	INT32U ret;

	FTL_CalPhyOpPar(&param, DieNo * ZONENUM_PER_DIE, SuBlkInDie, PageInSuBlk);

	param.SectorBitmapInPage = SectorBitmapInPage;
	param.MainDataPtr = DBuf;
	param.SpareDataPtr = (INT8U *)pSData;

	ret = PHY_PageRead(&param);
	if (PHY_READ_ERR(ret))
	{
		DMSG(DBL_WARNING, "[SCAN] %s: Read Err for Page %d of SuBlk %d in Die %d, ret %d\n",
			__FUNCTION__, PageInSuBlk, SuBlkInDie, DieNo, ret);
	}
        

	return ret;
}
static INT32U SuBlkPageReadSpare(INT32U DieNo, INT32U SuBlkInDie, INT32U PageInSuBlk, INT32U SectorBitmapInPage,
	INT8U *DBuf, struct NandSpareData *pSData)
{
	struct PhysicOpParameter param;
	INT32U ret;

	FTL_CalPhyOpPar(&param, DieNo * ZONENUM_PER_DIE, SuBlkInDie, PageInSuBlk);

	param.SectorBitmapInPage = SectorBitmapInPage;
	param.MainDataPtr = DBuf;
	param.SpareDataPtr = (INT8U *)pSData;

	ret = PHY_PageRead_Spare(&param);
	if (PHY_READ_ERR(ret))
	{
		DMSG(DBL_WARNING, "[SCAN] %s: Read Err for Page %d of SuBlk %d in Die %d, ret %d\n",
			__FUNCTION__, PageInSuBlk, SuBlkInDie, DieNo, ret);
	}
        

	return ret;
}


/**
 * \brief   Write a page of super block
 *
 * This routine writes one page of super block and syncs the flash to ready state.
 *
 * \param[in]  DieNo The die number that block in
 * \param[in]  SuBlkInDie The super block number in die
 * \param[in]  PageInSuBlk The page number in SuBlk
 * \param[in]  SectorBitmapInPage The sector bitmap of page
 * \param[in]  DBuf The buffer for data
 * \param[in]  pSData The pointer of NandSpareData
 *
 * \return  the search result
 *  - TRUE  Succeeded to write
 *  - FALSE  Failed to write
 *  - FALSE|ADDRERROR  the address is invalid;
 */
static INT32U SuBlkPageWrite(INT32U DieNo, INT32U SuBlkInDie, INT32U PageInSuBlk, INT32U SectorBitmapInPage,
	INT8U *DBuf, struct NandSpareData *pSData)
{
	struct PhysicOpParameter param;
	INT32U ret;

	FTL_CalPhyOpPar(&param, DieNo * ZONENUM_PER_DIE, SuBlkInDie, PageInSuBlk);


//	DMSG(DBL_INFO, "[SCAN] %s: Write to Page %d SuBlk %d Bank %u (page %u sublk %u die %u)\n",
//				__FUNCTION__, param.PageNum, param.PhyBlkNumInBank, param.BankNum,
//				PageInSuBlk, SuBlkInDie, DieNo);

	param.SectorBitmapInPage = SectorBitmapInPage;
	param.MainDataPtr = DBuf;
	param.SpareDataPtr = (INT8U *)pSData;

	ret = PHY_PageWrite(&param);

	ret = PHY_SyncNandOperation(param.BankNum);

	if (ret != TRUE)
	{
		DMSG(DBL_WARNING, "[SCAN] %s: Write Err for Page %d of SuBlk %d in Die %d, ret %d\n",
			__FUNCTION__, PageInSuBlk, SuBlkInDie, DieNo, ret);
	}

	return ret;
}

/**
 * \brief   Erase a super block
 *
 * This routine erases a super block and syncs the flash to ready state.
 *
 * \param[in]  DieNo The die number that block in
 * \param[in]  SuBlkInDie The super block number in die
 *
 * \return  the search result
 *  - TRUE  Succeeded to erase
 *  - FALSE  Failed to erase
 *  - FALSE|ADDRERROR  the address is invalid;
 */
static INT32U SuBlkErase(INT32U DieNo, INT32U SuBlkInDie)
{
	struct PhysicOpParameter param;
	INT32U ret;

	//DMSG(DBL_LOG, "[SCAN] %s: Erase sublk %u in die %d\n",
	//	__FUNCTION__, SuBlkInDie, DieNo);

	FTL_CalPhyOpPar(&param, DieNo * ZONENUM_PER_DIE, SuBlkInDie, 0);

	ret = PHY_EraseSuperBlk(&param);
	ret = PHY_SyncNandOperation(param.BankNum);

	if (ret != TRUE)
	{
		DMSG(DBL_WARNING, "[SCAN] %s: Erase Err for SuBlk %d in Die %d, ret %d\n",
			__FUNCTION__, SuBlkInDie, DieNo, ret);
	}

	return ret;
}

/**
 * \brief   Mark a super block as bad block
 *
 * This routine writes the bad block flag to the first page's of block spare area to
 * avoid using this block again.
 *
 * \param[in]  DieNo The die number that block in
 * \param[in]  SuBlkInDie The super block number in die
 *
 * \return  the search result
 *  - TRUE  Succeeded to erase
 *  - FALSE  Failed to erase
 *  - FALSE|ADDRERROR  the address is invalid;
 */
static INT32U SuBlkMarkBad(INT32U DieNo, INT32U SuBlkInDie)
{
	struct NandSpareData SData;
	INT32U ret;

	DMSG(DBL_LOG, "[SCAN] %s: Mark sublk %u as bad block in die %d\n",
		__FUNCTION__, SuBlkInDie, DieNo);

	SData.UserData[0].SpareData0.BadFlag = 0x0;

	ret = SuBlkPageWrite(DieNo, SuBlkInDie, 0, SECTOR_BITMAP_FULLPLANE, GPageBuf, &SData);
	if (ret != TRUE)
	{
		DMSG(DBL_WARNING, "[SCAN] %s: Write bad flag err for sublk %u in die %u, ret %d\n",
			__FUNCTION__, SuBlkInDie, DieNo, ret);
	}

	return ret;
}


/**
 * \brief   Copy a block content to other block
 *
 * This routine copys a full super block to other free super block including
 * main area data and spare area data.
 *
 * \param[in]  DieNo The die number that block in
 * \param[in]  SrcSuBlk The source super block number in die
 * \param[in]  DstSuBlk The destination super block number in die
 *
 * \return  the search result
 *  - TRUE  Succeeded to copy
 *  - FALSE  Failed to copy
 *  - FALSE|ADDRERROR  the address is invalid;
 */
static INT32U SuBlkCopy(INT32U DieNo, INT32U SrcSuBlk, INT32U DstSuBlk)
{
	struct PhysicOpParameter NandOpSrcPar;
	struct PhysicOpParameter NandOpDstPar;
	INT32U ret, page;

	DMSG(DBL_LOG, "[SCAN] %s: Copy sublk %u to sublk %u in die %d\n",
		__FUNCTION__, SrcSuBlk, DstSuBlk, DieNo);

	FTL_CalPhyOpPar(&NandOpSrcPar, DieNo * ZONENUM_PER_DIE, SrcSuBlk, 0);
	FTL_CalPhyOpPar(&NandOpDstPar, DieNo * ZONENUM_PER_DIE, DstSuBlk, 0);

	NandOpSrcPar.MainDataPtr = GPageBuf;
	NandOpSrcPar.SectorBitmapInPage = SECTOR_BITMAP_FULLPLANE;
	NandOpDstPar.SectorBitmapInPage = SECTOR_BITMAP_FULLPLANE;

	for (page = 0; page < PAGES_PER_SUBLK; page++)
	{
		NandOpSrcPar.PageNum = page;
		NandOpDstPar.PageNum = page;

		ret = PHY_CopyNandPage(&NandOpSrcPar, &NandOpDstPar);
		if (ret != TRUE)
		{
			DMSG(DBL_WARNING, "[SCAN] %s: Failed to copyback page %d from block %d  to block %d, ret %d\n",
				__FUNCTION__, page, SrcSuBlk, DstSuBlk, ret);

			return FALSE;
		}
	}

	return TRUE;
}

/**
 * \brief   Check the block if is a bad block
 *
 * This routine check the block if is a bad block, if MULTI_PLANE_SUPPORT check the second plane's
 * bad block flag too.
 *
 * \param[in]  pSData The NandSpareData poniter
 *
 * \return  the writting result
 *  - 0  Block is not a bad block.
 *  - 1  Block is a bad block.
 */
static inline INT32S IsBadSuBlk(struct NandSpareData *pSData)
{
#if 1
	if (pSData->UserData[0].SpareData0.BadFlag != BAD_BLK_FLAG
		||(MULTI_PLANE_SUPPORT && pSData->UserData[1].SpareData0.BadFlag != BAD_BLK_FLAG))
		return 1;
		
#endif
/* for debug: only first plane spare data is valid */
#if 0
	if (pSData->UserData[0].SpareData0.BadFlag != 0xff)
		return 1;
#endif

	return 0;
}



/**
 * \brief   Finds the log block index for a logical block in log block
 *
 * This routine gets the index in log block table of a logical block.
 *
 * \param[in]  szi The ScanZoneInfo pointer of this ogical block belongs to
 * \param[in]  LogcialBlk The logical block number
 *
 * \return  The index in log block table, or -1 if not fount in log block table
 */
static INT32U FindLogBlk(struct ScanZoneInfo *szi, INT32U LogcialBlk)

{
	INT32S i;

	for(i = 0; i < MAX_LOG_BLK_NUM; i++)
	{
		if (LogcialBlk == szi->LogBlkTbl[i].LogicBlkNum)
			return i;
	}

	return -1;
}

/**
 * \brief  Get the age sequence of a super block
 *
 * This routine gets the  age sequence of a super block by reading its spare data
 * that stored at page 0 of super block.
 *
 * \param[in]  DieNo The die number of this sublk
 * \param[in]  SuBlk The super block number in die
 *
 * \return  The age sequence of this super block
 */
static INT32U GetPhyBlkAge(INT32U DieNo, INT32U SuBlk)
{
	struct NandSpareData SData;
	INT32S ret;

	ret = SuBlkPageRead(DieNo, SuBlk, 0, SECTOR_BITMAP_SPAREDATA, GPageBuf, &SData);
	if (ret != TRUE)
	{
		/* */
	}
//	INIT_BOOT("SuBlk:%x,",SuBlk);
//	Str_printf(" ",(INT8U *)&SData,sizeof(struct NandSpareData));
	return (SData.UserData[0].SpareData1.LogStatus.LogBlkAge);
	
}

/**
 * \brief  Get a free block from current die
 *
 * This routine gets a free block by finding <ScanDieInfo.PhyBlkArray> array.
 *
 * \param[in]  sdi The ScanDieInfo Pointer of die
 *
 * \return  The free block number or -1 if cannot found a free block.
 */static INT32U GetFreeBlk(struct ScanDieInfo *sdi)
{
	INT32S sublk;

	for (sublk = sdi->LastFreeBlk; sublk <(INT32S) SUBLK_PER_DIE; sublk++)
	{
		if (sdi->PhyBlkArray[sublk] == BLOCK_STATE_FREE)
		{
			sdi->PhyBlkArray[sublk] = BLOCK_STATE_NIL;

			sdi->LastFreeBlk = sublk;
			sdi->FreeBlkCnt--;
			return sublk;
		}
	}

	return -1;
}

/**
 * \brief  Get the zone number that has least physical blocks
 *
 * This routine finds the zone which has least physical blocks in zones of this die.
 *
 * \param[in]  sdi The ScanDieInfo Pointer of die
 *
 * \return  The zone number that has least physical blocks
 */
static INT32U GetLeastFreeBlkZone(struct ScanDieInfo *sdi)
{
	INT32U zone, ZoneBlks, MinBlksZone, MinZoneBlks;

	MinBlksZone = 0;
	MinZoneBlks = ~0UL;

	for(zone = 0; zone < ZONENUM_PER_DIE; zone++)
	{
		if (sdi->ValidZoneTblFlag[zone])
			continue;

		ZoneBlks = (sdi->ZoneInfos[zone].DataBlkCnt + sdi->ZoneInfos[zone].FreeBlkCnt);
		if (ZoneBlks < MinZoneBlks)
		{
			MinZoneBlks = ZoneBlks;
			MinBlksZone = zone;
		}
	}

	return MinBlksZone;
}

/**
 * \brief  Get the last used zone table page in a super block of a die
 *
 * This routine finds the last  last used zone table page of this sublk by binary search arithmetic.
 * NOTE: The page 0 is always considered as used.
 *
 * \param[in]  DieNo The die number of this sublk
 * \param[in]  SuBlk The super block number in die
 *
 * \return  The last used page of this sublk
 */
static INT32U GetLastZoneTblPage(INT32U DieNo, INT32U SuBlk)
{
	struct NandSpareData SData;
	INT32S ret, mid, low, high, page,LastZoneTblPage;
                INT16U LogStatus;
	//INT8U bTmp;

	low = 0;
	high = (PAGES_PER_SUBLK - 1) / ZONETBL_PAGE_CNT;
                MEMSET(&SData, 0xFF, sizeof( struct NandSpareData));
	//bTmp = 	bPrintFlag;		
	//bPrintFlag =0x01;
	/* find the last non-empty page postion */
	while (low <= high )
	{
		mid = (low + high) / 2;
		page = mid * ZONETBL_PAGE_CNT;
		MEMSET(&SData, 0xFF, sizeof( struct NandSpareData));
		ret = SuBlkPageRead(DieNo, SuBlk, page, SECTOR_BITMAP_SPAREDATA, GPageBuf, &SData);
	
		LogStatus = SData.UserData[0].SpareData1.LogStatus.PhyPageStatus;


		/* check if empty page */
		if (LogStatus == PAGE_STATE_FREE)
			high = mid - 1;
		else
			low = mid + 1;
	}
	
	/* NOTE: page 0 is always used */
	LastZoneTblPage = ((low + high) / 2) * ZONETBL_PAGE_CNT;
///bPrintFlag =bTmp;
	return LastZoneTblPage;
}

/**
 * \brief  Get the last used zone table page in a super block of a die
 *
 * This routine finds the last  last used zone table page of this sublk by binary search arithmetic.
 * NOTE: The page 0 is always considered as used.
 *
 * \param[in]  DieNo The die number of this sublk
 * \param[in]  SuBlk The super block number in die
 * \param[out]  LastUsedPage The pointer to last used page number
 *
 * \return  result of searching result
 *  - TRUE: The last used page is page-mapping table
 *  - FALSE: The last used page is not page-mapping table
 */
//static INT32U GetLastPMTblPage(INT32U DieNo, INT32U SuBlk, INT32U *LastUsedPage)
static INT32U GetLastUsedPage(INT32U DieNo, INT32U SuBlk, INT32U *LastUsedPage)

{
	struct NandSpareData SData;
	INT32S ret, mid, low, high, page, bank;
	INT32U LastLogTblPage, TmpLastUsedPage;
	INT16U LogicalPageNum;

	INT8U PageStatus, BankPageStatus;


	low = 0;
	high = (PAGES_PER_SUBLK - 1) / TOTAL_BANKS;

	TmpLastUsedPage = 0;
	LastLogTblPage = 0;

	/* find the last non-empty page postion */
	while (low <= high )
	{
		mid = (low + high) / 2;

		BankPageStatus = 0xff;

		for (bank = 0; bank < (INT32S)TOTAL_BANKS; bank++)
		{
			page = mid * TOTAL_BANKS + bank;

			ret = SuBlkPageRead(DieNo, SuBlk, page, SECTOR_BITMAP_SPAREDATA, GPageBuf, &SData);
		
			PageStatus = SData.UserData[0].SpareData1.LogStatus.PhyPageStatus;
			LogicalPageNum = SData.UserData[0].SpareData1.LogicPageNum;
		
			/*
			 * The first page maybe a used page while PageStatus(Age) is equal to 0xff
			 * if its LogicalPageNum not equal to nil(0xffff).
			 */
			if ((PageStatus != PAGE_STATE_FREE)
				|| ( page == 0 &&  LogicalPageNum != 0xffff))
			{
				if (PageStatus == PAGE_STATE_PMTBL)
				{
					LastLogTblPage = page;
				}

				TmpLastUsedPage = page;
			}

			BankPageStatus &= PageStatus;
		}

		/* check if empty page */
		if (BankPageStatus == PAGE_STATE_FREE)
			high = mid - 1;
		else
			low = mid + 1;
	}

	/* NOTE: page 0 is always used */
	*LastUsedPage = TmpLastUsedPage;

	if (LastLogTblPage == TmpLastUsedPage)
		return TRUE;
	else
		return FALSE;
}

/**
 * \brief Get a free log block index in log block table.
 *
 * This routine searchs the log block table of zone to get a free log block index.
 *
 * \param[in]  szi The ScanZoneInfo struct pointer that to be search
 * \param[in]  SuBlk1 The first super block
 * \param[in]  SuBlk2 The second super block
 *
 * \return  return log block index if found a free log block, otherwise return -1.
 */
static inline INT32S GetFreeLogBlkIndex(struct ScanZoneInfo *szi)
{
	INT32S i;

	if (szi->LogBlkCnt > MAX_LOG_BLK_NUM)
		return -1;

	for (i = 0; i < MAX_LOG_BLK_NUM; i++)
	{
		if ((szi->LogBlkTbl[i].LogicBlkNum == 0xffff)
			&& (szi->LogBlkTbl[i].PhyBlkNum.PhyBlkNum == 0x0fff))
		{
			return i;
		}
	}

	return -1;
}

/**
 * \brief  Make a new zone block in zone table block area
 *
 * This routine makes a new zone block by swapping the block in zonetbl area to other area.
 * If desperation equal '1', search all blocks in zoneblk area inlucde block belonged to
 * zone which need not to rebuilt.
 *
 * \param[in]  sdi The ScanDieInfo Pointer of die
 * \param[in]  desperation The desperation flag
 *    - desperation = 0: Search blocks in zonetbl area only in block belonged to zones which need to rebuilt.
 *    - desperation = 1: Search all blocks in zone table block area.
 *
 * \return  Zone table block number, return -1 if cannot make a new zone table block
 */
static INT32S MakeNewZoneBlk(struct ScanDieInfo *sdi, INT32S desperation)
{
	struct ScanZoneInfo *szi;
	struct DataBlkTblType *pDataBlk;
	INT32U ret, zone, sublk, FreePhyBlk;
	INT16U LogBlkInfo, LogicalBlk;
	INT32S silly;

	DMSG(DBL_LOG, "[SCAN] MakeNewZoneBlk(DieNo: %u, desperation: %d) enter\n",
		sdi->DieNo, desperation);

	for (sublk = DIE_FIRST_SUBLK_NUM; sublk < MAX_ZONETBL_AREA_BLOCK; sublk++)
	{
		LogBlkInfo = sdi->PhyBlkArray[sublk];

		/* skip special block */
		if (LogBlkInfo& BLOCK_TYPE_SPECIAL)
			continue;

		zone = GetZoneTblNum(LogBlkInfo);
		LogicalBlk = GetLogBlockNum(LogBlkInfo);

		/* skip block belong to zone which need not rebuilt when desperation is not true */
		if (sdi->ValidZoneTblFlag[zone] && !desperation)
			continue;

		szi = &sdi->ZoneInfos[zone];
		pDataBlk = (struct DataBlkTblType *)&szi->ZoneTbl[LogicalBlk];

		/* We only use the data block, and maybe this is a log block */
		if (sublk != pDataBlk->PhyBlkNum)
			continue;

		/* copy this block to a free block, and find other free block to write if failed. */
		silly = 0;
		do
		{
			FreePhyBlk = GetFreeBlk(sdi);
			ret = SuBlkCopy(sdi->DieNo, sublk, FreePhyBlk);

			if (ret != TRUE)
				SuBlkMarkBad(sdi->DieNo, FreePhyBlk);

			/* avoid dead circulation */
			silly++;
			if (silly > 10)
			{
				DMSG(DBL_ERR, "%s: SuBlkCopy from %d failed too more times.\n",
					__FUNCTION__, sublk);
				return FALSE;
			}
		} while (ret != TRUE);


		DMSG(DBL_LOG, "%s: update zone table - change the original sublk %u to"
			"sublk %u for logical block %u of zone %u.\n",
			__FUNCTION__, sublk, FreePhyBlk, LogicalBlk, zone);

		/* update the zone table */
		pDataBlk->PhyBlkNum= FreePhyBlk;

		/* mark this changed zone table as unvalid, that is it need to be written to flash later. */
		if (sdi->ValidZoneTblFlag[zone])
		{
			struct NandSpareData SData;
			INT32U ZoneInFlash, phyblk, page;

			/* fill the zone information with the maximum value to avoid be allocate free blocks */
			szi->DataBlkCnt = DATA_BLK_NUM_PER_ZONE;
			szi->LogBlkCnt = MAX_ZONETBL_AREA_BLOCK;
			szi->FreeBlkInex = BLK_NUM_PER_ZONE - DATA_BLK_NUM_PER_ZONE - 1;

			sdi->ValidZoneTblFlag[zone] = 0;

			ZoneInFlash =ZONENO_IN_FLASH(sdi->DieNo, zone);
			phyblk = NandDevInfo.ZoneInfo[ZoneInFlash].PhyBlkNum;
			page = NandDevInfo.ZoneInfo[ZoneInFlash].TablePosition;

			/* set one sector dirty flag */
			MEMSET(GPageBuf, 0x55, 512);

			/* set the spare data of zone table page */
			MEMSET((INT8U *)&SData, 0xff, sizeof(struct NandSpareData));

			SData.UserData[0].SpareData1.LogStatus.PhyPageStatus = PAGE_STATE_USED;


			/* write zone table */
			ret = SuBlkPageWrite(sdi->DieNo, sublk, page + PAGE_OFFSET_DIRTYFLAG, SECTOR_BITMAP_FULLPLANE, GPageBuf, &SData);

		}

		ret = SuBlkErase(sdi->DieNo, sublk);
		if (ret) {
			/* mark it as omitted */
			SuBlkMarkBad(sdi->DieNo, sublk);
			sdi->PhyBlkArray[sublk] = BLOCK_STATE_NIL;

			/* unluckily, we need to find another new zone table block */
			continue;
		}

		/* return the block number in die happily */
		return sublk;
	}

	/* sorry, cannot make a new zone block in zoneblk area */
	return -1;
}

 /**
 * \brief  Get a new zone block in zone table block area
 *
 * This routine finds free block in zonetbl block area, and swap blocks to make new free
 * zone block if not found free block.
 *
 * \param[in]  sdi The ScanDieInfo Pointer of die
 *
 * \return  Zone table block number, return -1 if cannot get new zone table block
 */
static INT32S GetNewZoneBlk(struct ScanDieInfo *sdi)
{
	INT32S sublk;

	/* level 1: find free block in zone table block area. */
	for (sublk = DIE_FIRST_SUBLK_NUM; sublk < MAX_ZONETBL_AREA_BLOCK; sublk++)
	{
		if (sdi->PhyBlkArray[sublk] == BLOCK_STATE_FREE)
		{
			sdi->PhyBlkArray[sublk] = BLOCK_STATE_NIL;
			sdi->FreeBlkCnt--;
			return sublk;
		}
	}

	/* level 2: make a new zone block in zoneblk area from zone which need to be rebuilt. */
	sublk = MakeNewZoneBlk(sdi, 0);
	if (sublk != -1)
		return sublk;

	/* level 3: make a non-free block in zone table area include zone which need not to be rebuilt. */
	sublk = MakeNewZoneBlk(sdi, 1);
	if (sublk != -1)
		return sublk;

	return -1;
}

/**
 * \brief Compare the two super block last used paged.
 *
 * This routine
 *
 * \param[in]  DieNo The die number of sublk in
 * \param[in]  SuBlk1 The first super block
 * \param[in]  SuBlk2 The second super block
 *
 * \return  return 1 if the block which has last used page is SuBlk1, otherwise return 0.
 */
static inline INT32S SuBlkMoreUsedPage(INT32U DieNo, INT32U SuBlk1, INT32U SuBlk2)
{
	INT32S LastUsedPage1 = PAGES_PER_SUBLK - 1;
	INT32S LastUsedPage2 = PAGES_PER_SUBLK - 1;

	GetLastUsedPage(DieNo, SuBlk1, &LastUsedPage1);
	GetLastUsedPage(DieNo, SuBlk2, &LastUsedPage2);

	return (LastUsedPage1 > LastUsedPage2);
}


/**
 * \brief  Add a physical block to zone tables.
 *
 * This routine adds a physical super block to zone tables. By checking
 * the logical block information and age sequence, erases the invalid block to
 * ensure one logical block only has one data block or one data block and one
 * log block.
 *
 * \param[in]  sdi The ScanDieInfo Pointer of die
 * \param[in]  ZoneNo The zone number in die
 * \param[in]  LogicalBlkNo The logical block number
 * \param[in]  sublk The super block number in die
 *
 * \return  The block that need to be erase, -1 if no block need to be erase
 */

/* TODO: process 3 - 4  - 1 */
static INT32S AddBlkToZoneTbls(struct ScanDieInfo *sdi, INT32U ZoneNo, INT32U LogicalBlkNo, INT32U sublk)
{
	struct ScanZoneInfo *szi;
	struct DataBlkTblType *pDataBlk;
	INT32U PhyBlk_ToAdd, PhyBlk_InDataBlkTbl, PhyBlk_InLogBlkTbl;
	INT8U PhyBlkAge_ToAdd, PhyBlkAge_InDataBlkTbl, PhyBlkAge_InLogBlkTbl;
	INT32S LogIdx;
	INT32S EraseBlk = -1;

	/* step6: add block to zone table */
	szi = &sdi->ZoneInfos[ZoneNo];
	pDataBlk = (struct DataBlkTblType *)&szi->ZoneTbl[LogicalBlkNo];

	if (pDataBlk->PhyBlkNum== 0x0fff)
	{
		/* block is the first block of this logical block, add it to zone table */
		pDataBlk->PhyBlkNum = sublk;
		pDataBlk->EraseCnt = 0;
		szi->DataBlkCnt++;

		return -1;
	}
//INIT_BOOT("\nrun to :%s\n",__func__);
	/*
	 * There is already a physical block allocated for this logical blockin log block table,
	 * so we need to compare its age to decide which one should be put into log block table.
	 */
	PhyBlk_InDataBlkTbl = ((struct DataBlkTblType *)&szi->ZoneTbl[LogicalBlkNo])->PhyBlkNum;
	PhyBlkAge_InDataBlkTbl = GetPhyBlkAge(sdi->DieNo, PhyBlk_InDataBlkTbl);

	PhyBlk_ToAdd = sublk;
	PhyBlkAge_ToAdd = GetPhyBlkAge(sdi->DieNo, PhyBlk_ToAdd);

// 	INIT_BOOT("\n###LogicalBlkNo:%x PhyBlk  ToAdd:%x,DataBlkTbl:%x\n",LogicalBlkNo,PhyBlk_ToAdd,PhyBlk_InDataBlkTbl);
//        INIT_BOOT("Page:ToAdd: 0x%x,  InDataBlkTbl:  0x%x #\n",PhyBlkAge_ToAdd,PhyBlkAge_InDataBlkTbl);


	/* check if already has a physical block for this logical block in log block table */
	LogIdx = FindLogBlk(szi, LogicalBlkNo);

	if (SEQ_EQUAL(PhyBlkAge_ToAdd, PhyBlkAge_InDataBlkTbl))
	{
		if (SuBlkMoreUsedPage(sdi->DieNo, PhyBlk_ToAdd, PhyBlk_InDataBlkTbl))
		{
			/* ToAdd block is older, replace the phyblk for logical block in data block table */
			((struct DataBlkTblType *)&szi->ZoneTbl[LogicalBlkNo])->PhyBlkNum = PhyBlk_ToAdd;
			EraseBlk = PhyBlk_InDataBlkTbl;
		}
		else
		{
			/* ToAdd block is newer, and data maybe is not integral, so erase it */
			EraseBlk = PhyBlk_ToAdd;
		}

		goto out;
	}
	else if (SEQ_SMALLER(PhyBlkAge_ToAdd, PhyBlkAge_InDataBlkTbl))
	{
		INT32U tmp, tmp_age;
		/*
		 * the current physical block is newer than orig block,
		 * so swap the block in data block table
		 */
		tmp = PhyBlk_ToAdd;
		tmp_age = PhyBlkAge_ToAdd;

		((struct DataBlkTblType *)&szi->ZoneTbl[LogicalBlkNo])->PhyBlkNum = PhyBlk_ToAdd;

		PhyBlk_ToAdd = PhyBlk_InDataBlkTbl;
		PhyBlkAge_ToAdd = PhyBlkAge_InDataBlkTbl;
		PhyBlk_InDataBlkTbl = tmp;
		PhyBlkAge_InDataBlkTbl = tmp_age;

		if(PhyBlkAge_ToAdd != SEQ_NEXT(PhyBlkAge_InDataBlkTbl))
		{
			/* Not sequential, need to erase the block in log block table */
			if (LogIdx != -1)
			{
				PhyBlk_InLogBlkTbl = szi->LogBlkTbl[LogIdx].PhyBlkNum.PhyBlkNum;

				if (SuBlkErase(sdi->DieNo, PhyBlk_InLogBlkTbl))
				{
					/* mark it as free */
					sdi->PhyBlkArray[PhyBlk_InLogBlkTbl] = BLOCK_STATE_FREE;
					sdi ->FreeBlkCnt++;
				}
				else
				{
					/* mark it as omitted */
					sdi->PhyBlkArray[PhyBlk_InLogBlkTbl] = BLOCK_STATE_BAD;
					sdi ->BadBlkCnt++;
				}

				szi->LogBlkCnt--;
			}

			EraseBlk = PhyBlk_ToAdd;
			goto out;
		}

	}
	else if (PhyBlkAge_ToAdd != SEQ_NEXT(PhyBlkAge_InDataBlkTbl))
	{
		/* not sequential blocks */
		DMSG(DBL_WARNING, "[SCAN] %s: The ages of two physical block(LogicalBlkNo %u)"
			"are not sequential. (age1: %u, age2: %d)\n",
			__FUNCTION__, LogicalBlkNo, PhyBlkAge_InDataBlkTbl, PhyBlkAge_ToAdd);

		EraseBlk = PhyBlk_ToAdd;
		goto out;
	}
	else
	{
		/* The block to be added is sequential with the data block */
		/* do nothing */
	}

	/* The block to be added is sequential with the data block */

	if (LogIdx == -1)
	{
		LogIdx = GetFreeLogBlkIndex(szi);
		if (LogIdx == -1)
		{
			/* too many log blocks for this zone */
			DMSG(DBL_WARNING, "[SCAN] %s: LogBlkCnt %d exceed limit, erase sublk %u\n",
				__FUNCTION__, szi->LogBlkCnt, sublk);

			EraseBlk = PhyBlk_ToAdd;
			goto out;
		}

		/* Currently no log block for this logical block in log block table. */
		szi->LogBlkTbl[LogIdx].LogicBlkNum = LogicalBlkNo;
		szi->LogBlkTbl[LogIdx].PhyBlkNum.PhyBlkNum= PhyBlk_ToAdd;
		szi->LogBlkTbl[LogIdx].PhyBlkNum.EraseCnt= 0;

		szi->LogBlkCnt++;
	}
	else
	{

		/* too many log blocks for this logical block */
		DMSG(DBL_WARNING, "[SCAN] %s: Log block at index %d for logical block %u are not sequential.\n",
			__FUNCTION__, LogIdx, LogicalBlkNo);

		PhyBlk_InLogBlkTbl = szi->LogBlkTbl[LogIdx].PhyBlkNum.PhyBlkNum;
		PhyBlkAge_InLogBlkTbl = GetPhyBlkAge(sdi->DieNo, PhyBlk_InLogBlkTbl);

		/*
		 * If two block have same age, we need find who has more used page because the
		 * the block that has less used page maybe be interrupted suddenly in merge opearation.
		 */
		if (SEQ_EQUAL(PhyBlkAge_ToAdd, PhyBlkAge_InLogBlkTbl)
			&& SuBlkMoreUsedPage(sdi->DieNo, PhyBlk_InLogBlkTbl, PhyBlk_ToAdd))
		{
			/* ToAdd block is newer, and data maybe is not integral, so erase it */
			EraseBlk = PhyBlk_ToAdd;
		}
		else
		{
			/*
			 * the current physical block sequence is smaller than original log block,
			 * so need to replace the postion in log block table and erase the original log block.
			 */

			szi->LogBlkTbl[LogIdx].PhyBlkNum.PhyBlkNum = PhyBlk_ToAdd;
			szi->LogBlkTbl[LogIdx].PhyBlkNum.EraseCnt= 0;
			EraseBlk = PhyBlk_InLogBlkTbl;
		}

	}

out:
	return EraseBlk;
}

#ifdef CONFIG_SCAN_REBUILD_PMTBL

/**
 * \brief  Rebuild the page-mapping table for a log block
 *
 * This routine rebuilds the page-mapping table for a log block. If log block is full,
 * skips the rebuild process and leave the rebuild work to logical layer to avoiding
 * the complex merge operation.
 *
 * \param[in]  DieNo: the die number in flash
 * \param[in]  LogSuBlk: the SuBlk number of log block in die
 * \param[in,out] pLastUsedPage: the pointer which point to the last used page in log sublk
 *
 * \return  the rebuilding result
 *  - TRUE Succeeded to rebuild page-mapping table
 *  - FALSE Failed to  rebuild page-mapping table
 */
static INT32U RebuildPageMappingTbl(INT32U DieNo, INT32U LogSuBlk, INT32U *pLastUsedPage)
{
	struct PageMapTblType *PMTbl;
	struct NandSpareData SData;
	INT32U ret, page, PMTblSize;
	INT16U LogicPageNum;
	INT8U PageStatus;

	DMSG(DBL_LOG, "[SCAN] RebuildPageMappingTbl(DieNo: %u, LogSuBlk %u, LastUsedPage: %u) enter\n",
		DieNo, LogSuBlk, *pLastUsedPage);

	/* IF block is full, not rebuild work need delay to FTL layer */
	if (*pLastUsedPage >= (PAGES_PER_SUBLK - 1))
	{
		DMSG(DBL_LOG, "[SCAN] %s: Full log block(lastusedpage: %u), delay the rebuild work to logical layer\n",
			__FUNCTION__, *pLastUsedPage);
		return TRUE;
	}

	PMTblSize = PAGES_PER_SUBLK * sizeof(struct PageMapTblType);
	PMTbl = (struct PageMapTblType *)GPMTblBuf;
	MEMSET((INT8U *)PMTbl, 0xff, PMTblSize);

	/* scan the logical page mapping information */
	for (page = 0; page <= *pLastUsedPage; page++)
	{
		ret = SuBlkPageRead(DieNo, LogSuBlk, page, SECTOR_BITMAP_SPAREDATA, GPageBuf, &SData);
 
		LogicPageNum = SData.UserData[0].SpareData1.LogicPageNum;
		PageStatus = SData.UserData[0].SpareData1.LogStatus.PhyPageStatus;
		DASSERT((page == 0) && (SData.UserData[0].SpareData0.LogicBlkInfo == 0xffff));


		if ((page == 0) || (PageStatus == PAGE_STATE_USED))
		{
			if (LogicPageNum < PAGES_PER_SUBLK)
			{
				PMTbl[LogicPageNum].PhyPageNum = page;
			}
			else
			{
				DMSG(DBL_WARNING, "[SCAN] %s: Log block logical page %u exceeds limit (page: %u, sublk: %u, DieNo: %u)\n",
					__FUNCTION__, LogicPageNum, page, LogSuBlk, DieNo);
			}
		}
	}

	MEMCPY(GPageBuf, GPMTblBuf, PMTblSize);

	/* caculate table checksum */
	*(INT16U *)&GPageBuf[TABLE_CHKSUM_OFFSET] =
			_GetCheckSum((INT16U *)GPageBuf, PMTblSize / sizeof(INT16U));

	/* set spare data of page */
	MEMSET(&SData, 0xff, sizeof(struct NandSpareData));

	SData.UserData[0].SpareData1.LogStatus.PhyPageStatus = PAGE_STATE_PMTBL;


	(*pLastUsedPage)++;

	/* write page-mapping table */
	ret = SuBlkPageWrite(DieNo, LogSuBlk, *pLastUsedPage, SECTOR_BITMAP_FULLPLANE, GPageBuf, &SData);
	if (ret != TRUE)
	{
		DMSG(DBL_WARNING, "[SCAN] %s: Failed to write page-mapping table (page: %u, sublk: %u, DieNo: %u)\n",
			__FUNCTION__, *pLastUsedPage, LogSuBlk, DieNo);
	}

	DMSG(DBL_LOG, "[SCAN] %s: write page-mapping table to page %u (sublk: %u, DieNo: %u)\n",
		__FUNCTION__, *pLastUsedPage, LogSuBlk, DieNo);

	return ret;
}
#endif

#ifdef DBG_DUMP_DIE_INFO
static void DbgDumpDieInfo(struct ScanDieInfo *sdi)
{
	struct ScanZoneInfo *szi;
	struct LogBlkTblType *log;
	INT32U zone, logblk;

	INIT_DBG("Die filling inormation\n");
	INIT_DBG("-----------------------\n");
	INIT_DBG("DieNo: %u\n",sdi->DieNo);
	INIT_DBG("block count: %u\n", SUBLK_PER_DIE);
	INIT_DBG("free block: %u\n", sdi->FreeBlkCnt);
	INIT_DBG("bad block: %u\n", sdi->BadBlkCnt);


	for (zone = 0; zone < ZONENUM_PER_DIE; zone++)
	{
		szi = &sdi->ZoneInfos[zone];

		INIT_DBG("ZoneNo: %u\n", zone);
		INIT_DBG("    data block count: %u\n", szi->DataBlkCnt);
		INIT_DBG("    log block count: %u\n", szi->LogBlkCnt);

		INIT_DBG("    log block table: \n");
		INIT_DBG("    [Index]    [LogicalBlk]    [LogBlk]    [DataBlk]\n");
		for (logblk = 0; logblk < MAX_LOG_BLK_NUM; logblk++)
		{
			log = &szi->LogBlkTbl[logblk];
			INIT_DBG("      %2x          %04x           %04x        %04x\n",
				logblk, log->LogicBlkNum, log->PhyBlkNum.PhyBlkNum,
				(log->LogicBlkNum == 0xffff) ? 0xffff :
				((struct DataBlkTblType *)&szi->ZoneTbl[log->LogicBlkNum])->PhyBlkNum);
		}
	}
}
#endif

#ifdef DBG_DUMP_ZONE_TBLS
static void DbgDumpZoneTbls(struct ScanDieInfo *sdi)
{
	struct ScanZoneInfo *szi;
	INT32S zone, ZoneTblSize, LogTblSize;

	ZoneTblSize =  (BLK_NUM_PER_ZONE - 1) * sizeof(INT16U);
	LogTblSize = MAX_LOG_BLK_NUM *  sizeof(struct LogBlkTblType);

	for (zone = 0; zone < (INT32S)ZONENUM_PER_DIE; zone++)
	{
		szi = &sdi->ZoneInfos[zone];

		ScanReadZoneTbl(sdi, zone);

		INIT_DBG("zone table %d for die %d\n", zone, sdi->DieNo);

		INIT_DBG("data block table:\n");
		dump_mem((INT8U *)&szi->ZoneTbl, DATA_BLK_NUM_PER_ZONE * sizeof(INT16U), 0, 2);

		INIT_DBG("free block table:\n");
		dump_mem((INT8U *)(&szi->ZoneTbl[DATA_BLK_NUM_PER_ZONE]),
			 (BLK_NUM_PER_ZONE - 1 - DATA_BLK_NUM_PER_ZONE) * sizeof(INT16U), 0, 2);

		INIT_DBG("log block table:\n");
		dump_mem((INT8U *)&szi->LogBlkTbl, LogTblSize, 0, 1);
	}

}

#endif

/**
 * \brief  Read physical block information of a die
 *
 * This routine reads the physical block information of a die to <ScanDieInfo.PhyBlkArray>
 * structure. And by reading bad block flag in spare area of block, skips the bad block.
 *
 * \param[in]  sdi The ScanDieInfo Pointer of die
 *
 * \return  the reading result
 *  - TRUE  Succeeded to read physical block information
 *  - FALSE  Failed to read physical block information
 */
static INT32U ScanReadDieBlkInfo(struct ScanDieInfo *sdi)
{
	struct NandSpareData SData;
	INT32U BBFP_Bitmap, LogicBlkInfo;
	INT32S ret, i, sublk, bank, page, BadFlag;
	INT32S read_pages[4];

	LogicBlkInfo = BLOCK_STATE_FREE;

	/* bad block flag postion bitmap */
	BBFP_Bitmap = NandDevInfo.SpecialCommand->BadBlkFlagPst;

	/* init read pages */
	read_pages[0] = 0;	/* page 0 always be read for getting the logical block info */
	read_pages[1] = -1;
	read_pages[2] = -1;
	read_pages[3] = -1;

	switch (BBFP_Bitmap)
	{
		case BBF_POS_PAGE0_1:
			read_pages[1] = 1;
			break;
		case BBF_POS_LASTPAGE0:
			read_pages[2] = PAGE_CNT_PER_PHY_BLK- 1;
			break;
		case BBF_POS_LASTPAGE0_1:
			read_pages[2] = PAGE_CNT_PER_PHY_BLK- 1;
			read_pages[3] = PAGE_CNT_PER_PHY_BLK- 2;
			break;
		case BBF_POS_PAGE0:
		default:
			break;
	}
	MEMSET(&SData, 0xFF, sizeof( struct NandSpareData));
	for (sublk = DIE_FIRST_SUBLK_NUM; sublk < (INT32S)SUBLK_PER_DIE; sublk++)
	{
		BadFlag = 0;

		for (bank = 0; bank < (INT32S)TOTAL_BANKS; bank++)
		{
			/* only read the first sector of block */
			for (i = 0; i < 4; i++)
			{
				if (read_pages[i] == -1)
					continue;

				page = read_pages[i] * TOTAL_BANKS + bank;

				ret = SuBlkPageRead(sdi->DieNo, sublk, page,
					SECTOR_BITMAP_BBF, GPageBuf, &SData);

			//	printf("sublk:%d ",sublk);
			//	Str_printf("",  &SData, sizeof( struct NandSpareData));   
				if (IsBadSuBlk(&SData)){
					BadFlag = 1;
	
					//    Str_printf("",  &SData, 24);   
					goto Check_BadBlk;
				}
				else if (page ==0)
				{
				/* LogicBlkInfo is stored in the spare area of page 0. */
			
					LogicBlkInfo = SData.UserData[0].SpareData0.LogicBlkInfo;
			
				}
			}
		}

Check_BadBlk:
		if (BadFlag)
		{
			DMSG(DBL_INFO, "[SCAN] %s: Found bad block %u (DieNo: %u)\n",
				__FUNCTION__, sublk, sdi->DieNo);
			sdi->PhyBlkArray[sublk] = BLOCK_STATE_BAD;
		}
		else
		{
			sdi->PhyBlkArray[sublk] = LogicBlkInfo;
		}
	}
//Dump_mem(sdi->PhyBlkArray,2048,0,2);
//return FALSE;
	return TRUE;
}

/**
 * \brief  Fill the zone tables.
 *
 * This routine fills the zone tables that need be rebult of a die. By checking
 * the logical block information and age sequence, erases the invalid block to
 * ensure one logical block only has one data block or one data block and one
 * log block.
 *
 * \param[in]  sdi The ScanDieInfo Pointer of die
 *
 * \return  the filling result
 *  - TRUE  Succeeded to fill zone tables
 *  - FALSE  Failed to fill zone tables
 *  - FALSE|ADDRERROR  the address is invalid;
 */
static INT32U ScanFillZoneTbls(struct ScanDieInfo *sdi)
{
	INT32U LogicBlkInfo, LogicalBlkNo, ZoneNo;
	INT32S sublk, EraseBlk, NeedErase;

	DMSG(DBL_LOG, "[SCAN] ScanFillZoneTbls(DieNo: %d) in.\n", sdi->DieNo);

#if  0// BREC_DRIVER ==0x01
	INT32U bb;
	bb =0x00;
	INIT_BOOT("##########run to :%s ############\n",__func__);
	for (sublk = DIE_FIRST_SUBLK_NUM; sublk < (INT32S)SUBLK_PER_DIE; sublk++)
	{
		LogicBlkInfo = sdi->PhyBlkArray[sublk];
		if(LogicBlkInfo == BLOCK_STATE_FREE)
		{
			INIT_BOOT("%4x ",sublk);					
			if( 0== ((bb+1) &0x0f) )	
			{
				INIT_BOOT("\n");
			}
			bb++;
		}
	}
	INIT_BOOT("\n");
#endif

//Dump_mem(sdi->PhyBlkArray,2048,0,2);
	for (sublk = DIE_FIRST_SUBLK_NUM; sublk < (INT32S)SUBLK_PER_DIE; sublk++)
	{
		NeedErase = 0;
		EraseBlk = sublk;
		LogicBlkInfo = sdi->PhyBlkArray[sublk];

		/* step1: check if a bad block */
		if(LogicBlkInfo == BLOCK_STATE_BAD)
		{
			sdi->BadBlkCnt++;
			continue;
		}

		/* step2: check if a free block */
		if(LogicBlkInfo == BLOCK_STATE_FREE)
		{
			/* check if a free block is actually FREE, is this check really necessary? */

			sdi->FreeBlkCnt++;
			continue;
		}

		/* step3: check if a special block */
		if(LogicBlkInfo & BLOCK_TYPE_SPECIAL)
		{
			INT32U SpecialBlkType = GetBlockType(LogicBlkInfo);

			if (SpecialBlkType == BLOCK_TYPE_ZONETBL)
			{
				/* check if zone table block not in zone table block area */
				if (sublk >= MAX_ZONETBL_AREA_BLOCK)
				{
					/* unknown special block */
					DMSG(DBL_WARNING, "[SCAN] %s: zone table block %u is not in zone table area.\n",
						__FUNCTION__, sublk);

					NeedErase = 1;
					goto erase;
				}
				else
				{
					continue;
				}
			}
			else if (SpecialBlkType == BLOCK_TYPE_BREC)
			{
				continue;
			}
			else
			{
				/* unknown special block */
				DMSG(DBL_WARNING, "[SCAN] %s: unknow special block %u.%x\n",
					__FUNCTION__, sublk,LogicBlkInfo);

				NeedErase = 1;
				goto erase;
			}

		}

		/* step4: check if logic block num is valid */
		ZoneNo = GetZoneTblNum(LogicBlkInfo);
		LogicalBlkNo = GetLogBlockNum(LogicBlkInfo);
		if((ZoneNo >= ZONENUM_PER_DIE) ||
			(LogicalBlkNo >= NandDevInfo.LogicOrganizePar->DataBlkNumPerZone))
		{
			DMSG(DBL_WARNING, "[Scan] %s: Invalid logicalBlkInfo of block %u.\n",
				__FUNCTION__, sublk);

			NeedErase = 1;
			goto erase;
		}

		/* step5: check if block belong to zones that need not to rebuild */
		if (sdi->ValidZoneTblFlag[ZoneNo])
			continue;

		/* step6: add block to zone table */
		EraseBlk = AddBlkToZoneTbls(sdi, ZoneNo, LogicalBlkNo, sublk);
		if (EraseBlk != -1)
		{
			NeedErase = 1;
			INIT_BOOT("run to:%s,%d  erase blk:%x\n",__func__,__LINE__,sublk);
		}

erase:
		/* erase this physical block if needed */
		if (NeedErase)
		{
			if(!SuBlkErase(sdi->DieNo, EraseBlk))
			{
				/* mark it as free */
				sdi->PhyBlkArray[EraseBlk] = BLOCK_STATE_FREE;
				sdi ->FreeBlkCnt++;
			} else
			{
				/* mark it as omitted */
				sdi->PhyBlkArray[EraseBlk] = BLOCK_STATE_BAD;
				sdi ->BadBlkCnt++;
			}
		}
	}

#ifdef DBG_DUMP_DIE_INFO
	DbgDumpDieInfo(sdi);
#endif
#if 0//BREC_DRIVER ==0x01
	//INT32U bb;
	bb =0x00;
	for (sublk = DIE_FIRST_SUBLK_NUM; sublk < (INT32S)SUBLK_PER_DIE; sublk++)
	{
		LogicBlkInfo = sdi->PhyBlkArray[sublk];
		if(LogicBlkInfo == BLOCK_STATE_FREE)
		{
			INIT_BOOT("%4x ",sublk);					
			if( 0== ((bb+1) &0x0f) )	
			{
				INIT_BOOT("\n");
			}
			bb++;
		}
	}
	INIT_BOOT("\n");
#endif

	DMSG(DBL_LOG, "[SCAN] ScanFillZoneTbls(DieNo: %d) out.\n", sdi->DieNo);

	return TRUE;
}

/**
 * \brief  Remove the free blocks that already be allocated.
 *
 * This routine removes the free blocks that already be allocated to zones that
 * need not be rebuild to avoiding free block be used duplicately.
 *
 * \param[in]  sdi  The ScanDieInfo Pointer of die
 *
 * \return  the removing result
 *  - TRUE  Succeeded to removing free blocks
 *  - FALSE  Failed to removing free blocks
 */
static INT32U ScanRemoveAllocatedFreeBlks(struct ScanDieInfo *sdi)
{
	struct ScanZoneInfo *szi;
	INT32S ret, zone, sublk, LogicalBlk;

	for(zone = 0; zone < (INT32S)ZONENUM_PER_DIE; zone++)
	{
		if (!sdi->ValidZoneTblFlag[zone])
			continue;

		szi = &sdi->ZoneInfos[zone];

		/*read the valid zone table */
		ret = ScanReadZoneTbl(sdi, zone);
		if (ret != TRUE)
		{
			DMSG(DBL_ERR, "[SCAN] ScanReadZoneTbl(DieNo: %d, Zone: %d) failed, ret %d.\n",
				sdi->DieNo, zone, ret);
			continue;
		}

		for (LogicalBlk = 0; LogicalBlk < BLK_NUM_PER_ZONE; LogicalBlk++)
		{
			sublk = ((struct DataBlkTblType *)&szi->ZoneTbl[LogicalBlk])->PhyBlkNum;

			/* skip nil item */
			if (sublk == 0x0fff)
				continue;

			/* check if this block is a free block */
			if (sdi->PhyBlkArray[sublk] == BLOCK_STATE_FREE)
			{
				/* this free block is already allocated, so mark it as omitted */
				sdi->PhyBlkArray[sublk] = BLOCK_STATE_NIL;
				sdi->FreeBlkCnt--;
			}
		}

	}

	return TRUE;
}

/**
 * \brief  Allocates the zone table blocks for zones.
 *
 * This routine allocates the zone table blocks at zone table block area for zones
 * that need be rebuild.
 *
 * \param[in]  sdi The ScanDieInfo Pointer of die
 *
 * \return  the allocating result
 *  - TRUE  Succeeded to allocate zone table blocks
 *  - FALSE  Failed to allocate zone table blocks
 */
static INT32U ScanAllocatedZoneTblBlks(struct ScanDieInfo *sdi)
{
	INT32S ret, zone, ZoneBlk, ZoneInFlash;
      
	ret = TRUE;

	for(zone = 0; zone < (INT32S)ZONENUM_PER_DIE; zone++) {

		/* skip zone which need not to be rebuilt */
		if (sdi->ValidZoneTblFlag[zone])
			continue;

		ZoneInFlash = ZONENO_IN_FLASH(sdi->DieNo, zone);

		/* skip zone that already has zone table block */
		ZoneBlk = NandDevInfo.ZoneInfo[ZoneInFlash].PhyBlkNum;
		if (ZoneBlk < MAX_ZONETBL_AREA_BLOCK)
			continue;

		/* not in zone table area, need to find a new zone table block */
		ZoneBlk = GetNewZoneBlk(sdi);
		if (ZoneBlk == -1)
		{
			DMSG(DBL_ERR, "%s: sorry, cannot found free blocks in zone table block area for zone %d.\n",
				__FUNCTION__, ZoneInFlash);
			ret = FALSE;
			break;
		}
#if 0
		/* check the block if is really free */
		 if(!DbgCheckBlkFree(sdi->DieNo, ZoneBlk)) {
			DMSG(DBL_ERR, "%s: Block %d is not really free block, erase it now.\n",
				__FUNCTION__, ZoneBlk);

			SuBlkErase(sdi->DieNo, ZoneBlk);
		 }
#endif

		/* use this block as zone table block */
		NandDevInfo.ZoneInfo[ZoneInFlash].PhyBlkNum = ZoneBlk;
		NandDevInfo.ZoneInfo[ZoneInFlash].TablePosition = 0x0fff;

		/* mark this block that already be allocated as zone block */
		sdi->PhyBlkArray[ZoneBlk] =
			BLOCK_TYPE_SPECIAL | (zone << 10) | BLOCK_TYPE_ZONETBL;
	}
	
	return ret;
}

/**
 * \brief  Check page-mapping tables of each log block.
 *
 * This routine gets the last used page of a log block, and check if it is a valid
 * page-mapping table. If table is not found or checksum error, rebuilds it.
  *
 * \param[in]  sdi The ScanDieInfo Pointer of die
 *
 * \return  the checking result
 *  - TRUE  Succeeded to check page-mapping tables
 *  - FALSE  Failed to check page-mapping tables
  *  - FALSE|ADDRERROR  the address is invalid;
 */
static INT32U ScanCheckPageMappingTbls(struct ScanDieInfo *sdi)
{
	struct ScanZoneInfo *szi;
	INT32S ret, zone, sublk, LogBlk, LastUsedPage;

	DMSG(DBL_LOG, "[SCAN] %s(): enter.\n", __FUNCTION__);

	GPMTblBuf = (INT8U*)MALLOC(PAGES_PER_SUBLK * sizeof(struct PageMapTblType));

	for(zone = 0; zone < (INT32S)ZONENUM_PER_DIE; zone++)
	{
		if (sdi->ValidZoneTblFlag[zone])
			continue;

		szi = &sdi->ZoneInfos[zone];

		for(LogBlk = 0; LogBlk < MAX_LOG_BLK_NUM; LogBlk++)
		{
			/* skip free log block or nil log block*/
			sublk = szi->LogBlkTbl[LogBlk].PhyBlkNum.PhyBlkNum;
			if ((szi->LogBlkTbl[LogBlk].LogicBlkNum == 0xffff) || (sublk == 0x0fff))
			{
				continue;
			}

			/* check if the last used page is a page-mapping table */
			ret = GetLastUsedPage(sdi->DieNo, sublk, &LastUsedPage);
			if (ret != TRUE)
			{
#ifdef CONFIG_SCAN_REBUILD_PMTBL

				ret = RebuildPageMappingTbl(sdi->DieNo, sublk, &LastUsedPage);
#endif
			}

			szi->LogBlkTbl[LogBlk].LastUsedPage = LastUsedPage;
		}

	}

	FREE(GPMTblBuf);
	GPMTblBuf = NULL;

	DMSG(DBL_LOG, "[SCAN] %s(): out, ret %u\n", __FUNCTION__, TRUE);

	return TRUE;
}

/**
 * \brief  Distributes free blocks averagely to zones that need rebuild.
 *
 * This routine distributes the free blocks for zones. Firstly using free blocks to
 * fills the data block table, it must be success otherwise report failed and return err.
 * Second, fills the free block table averagely according to block numbers of log block
 * and free blocks.
 *
 * \param[in]  sdi The ScanDieInfo Pointer of die
 *
 * \return  the distributing result
 *  - TRUE  Succeeded to distribute free blocks
 *  - FALSE  Failed to  distribute free blocks
 */
static INT32U ScanDistributeFreeBlks(struct ScanDieInfo *sdi)
{
	struct ScanZoneInfo *szi;
	INT32S ret, i, zone, blk;

	DMSG(DBL_LOG, "[SCAN] %s(): enter.\n", __FUNCTION__);
	szi =NULL;
	/* use free blocks to fill the <Data Block Table> of zones which need to be rebuilt  */
	for(zone = 0; zone < (INT32S)ZONENUM_PER_DIE; zone++)
	{
		INT32S NeedFillDataBlks;

		szi = &sdi->ZoneInfos[zone];
		if (sdi->ValidZoneTblFlag[zone])
			continue;

		NeedFillDataBlks = NandDevInfo.LogicOrganizePar->DataBlkNumPerZone - szi->DataBlkCnt;
		if (sdi->FreeBlkCnt< NeedFillDataBlks)
		{
			DMSG(DBL_ERR, "%s: failed to fill nand zone table %d in die %d, need %d, but only have %d free blocks\n",
				__FUNCTION__, zone, sdi->DieNo, NeedFillDataBlks, sdi->FreeBlkCnt);
			ret = FALSE;
			break;
		}

		/* use free blocks to fill this azone table */
		for (i = 0; i < NandDevInfo.LogicOrganizePar->DataBlkNumPerZone; i++)
		{
			struct DataBlkTblType *pDataBlk = (struct DataBlkTblType *)&szi->ZoneTbl[i];

			if (pDataBlk->PhyBlkNum ==  0x0fff)
			{
				blk = GetFreeBlk(sdi);
				if (blk == -1) {
					DMSG(DBL_ERR, "%s: failed to get free block for die %d zone %d\n",
						__FUNCTION__, sdi->DieNo, zone);
					ret = FALSE;
					break;
				}

				pDataBlk->PhyBlkNum = blk;
				pDataBlk->EraseCnt = 0;
				szi->DataBlkCnt++;
			}
		}

	}

	/* use free blocks to fill the <Free Block Table> of zones which need to be rebuilt  */
	struct DataBlkTblType *pFreeBlk;

	INT32U FreeBlkTblStart;
	INT32U TotalFreeBlk;

	/*@fish add 2010-01-04*/	
	{
	     TotalFreeBlk =0x00;
                        printf("####run to :%s,%d   ####\n",__func__,__LINE__);
	     for(zone = 0; zone < (INT32S)ZONENUM_PER_DIE; zone++)
	     {
	            printf("Zone:%d,data:%x,log:%x,Free:%x\n", zone,szi->DataBlkCnt,szi->LogBlkCnt,szi->FreeBlkCnt);		 
	            szi = &sdi->ZoneInfos[zone];
	            if (sdi->ValidZoneTblFlag[zone])
	                  continue;	         
	            TotalFreeBlk+=MAX_FREE_BLK_CNT-szi->LogBlkCnt;
	     }
	     printf("TotalFreeBlk:%x,FreeBlkCnt:%x,%x\n",TotalFreeBlk,sdi->FreeBlkCnt,sdi->BadBlkCnt);
	     if(TotalFreeBlk > sdi->FreeBlkCnt)
	     {	         
	           return FALSE;
	     }
	}

	FreeBlkTblStart =  NandDevInfo.LogicOrganizePar->DataBlkNumPerZone;

	while (sdi->FreeBlkCnt> 0) {
		INT32S sublk;

		zone = GetLeastFreeBlkZone(sdi);

		/* use free blocks to fill this szone table */
		szi = &sdi->ZoneInfos[zone];

		pFreeBlk = (struct DataBlkTblType *)&szi->ZoneTbl[FreeBlkTblStart + szi->FreeBlkInex];

		if (szi->FreeBlkInex <(INT32S) (BLK_NUM_PER_ZONE - FreeBlkTblStart))
		{
			sublk = GetFreeBlk(sdi);
			if (sublk == -1)
			{
				DMSG(DBL_ERR, "[SCAN] %s: Failed to get free block for die %d zone %d\n", __FUNCTION__, sdi->DieNo, zone);
				break;
			}
			pFreeBlk->PhyBlkNum = sublk;
			pFreeBlk->EraseCnt = 0;

			szi->FreeBlkInex++;
			szi->FreeBlkCnt++;
		}
		else
		{
			DMSG(DBL_WARNING, "[SCAN] %s: Still has %d free physical block not allocated.\n",
				__FUNCTION__, sdi->FreeBlkCnt);
			break;
		}
	}

	DMSG(DBL_LOG, "[SCAN] %s(): out, ret %d.\n", __FUNCTION__, TRUE);

	return TRUE;
}


/**
 * \brief  Read a valid zone table from flash
 *
 * This routine reads a zone table by postion infomation at the <NandDev.ZonInfo>,
 * and don't check the validation of the zone table.
 *
 * \param[in]  sdi The ScanDieInfo Pointer of die
 * \param[in]  zone The zone number that need be read
 *
 * \return  the search result
 *  - TRUE  Succeeded to read zone table
 *  - FALSE  Failed to read zone table
 *  - FALSE|ECCERROR  the ecc error;
 *  - FALSE|ADDRERROR  the address is invalid;
 */
static INT32U ScanReadZoneTbl(struct ScanDieInfo *sdi, INT32U zone)
{
	struct ScanZoneInfo *szi;
	struct NandSpareData SData;
	INT32S ret, sublk, page, ZoneInFlash, TblSize;
	INT32U bitMap;

	DMSG(DBL_LOG, "[SCAN] %s(zone: %u): enter.\n", __FUNCTION__, zone);

	szi = &sdi->ZoneInfos[zone];

	/* don't read the zone table that  need be rebuilt */
	if (!sdi->ValidZoneTblFlag[zone])
		return FALSE;

	/* get the block postion of zone table */
	ZoneInFlash = ZONENO_IN_FLASH(sdi->DieNo, zone);
	sublk = NandDevInfo.ZoneInfo[ZoneInFlash].PhyBlkNum;
	page = NandDevInfo.ZoneInfo[ZoneInFlash].TablePosition;

	if(SECTOR_NUM_PER_SINGLE_PAGE ==Page_Size2K) //Page 2KB 
	{
		bitMap = SECTOR_BITMAP_ZONETBL;
	}
	else
	{
		bitMap= BITMAP_ZONETBL_4K;
	}

	/* TODO: not erase zone block, and write to the following page ? */
	ret = SuBlkPageRead(sdi->DieNo, sublk, page + ZONETBL_OFFSET, bitMap, GPageBuf, &SData);
	if (ret != TRUE)
	{
	/*  */
	}

#if _NEW_ZONE_TBL_==0x01	
	if(SECTOR_NUM_PER_SINGLE_PAGE ==Page_Size2K) //Page 2KB 
	{
		ret = SuBlkPageRead(sdi->DieNo, sublk, page + ZONETBL_OFFSET+1, bitMap, GPageBuf+2048, &SData);
	}   

	TblSize = (BLK_NUM_PER_ZONE - 1) * sizeof(INT32U);
	MEMCPY(&szi->ZoneTbl, GPageBuf, TblSize);
#else
	TblSize = (BLK_NUM_PER_ZONE - 1) * sizeof(INT16U);
	MEMCPY((INT8S*)&szi->ZoneTbl, GPageBuf, TblSize);
#endif
	ret = SuBlkPageRead(sdi->DieNo, sublk, page + LOGTBL_OFFSET, SECTOR_BITMAP_ZONETBL, GPageBuf, &SData);
	if (ret != TRUE)
	{
		/*  */
	}

	TblSize = MAX_LOG_BLK_NUM *  sizeof(struct LogBlkTblType);
	MEMCPY((INT8S*)&szi->LogBlkTbl, GPageBuf, TblSize);

	DMSG(DBL_LOG, "[SCAN] %s(zone: %u): out.\n", __FUNCTION__, zone);

	return TRUE;
}

/**
 * \brief  Writes zone tables that be rebuild.
*
 * This routine writes zone tables of a die that need rebuild. If failed to write, return
 * SCAN_ERR_TRY_AGAIN.
 *
 * \param[in]  sdi The ScanDieInfo Pointer of die
 *
 * \return  the writting result
 *  - TRUE  Succeeded to write zone tables
 *  - FALSE  Failed to write  zone tables
 *  - SCAN_ERR_TRY_AGAIN: Try again and maybe it will be sucess.
 */
static INT32U ScanWriteZoneTbls(struct ScanDieInfo *sdi)
{
	struct ScanZoneInfo *szi;
	struct NandSpareData SData;
	INT32S ret, zone, sublk, page;
	INT32S ZoneInFlash, TblSize;
	static INT32S WriteRetryTImes = 0;
	INT32U bitMap;
	INT16U iLoop;

	ret = TRUE;

	DMSG(DBL_LOG, "[SCAN] %s(DieNo: %d): enter.\n", __FUNCTION__, sdi->DieNo);

	for(zone = 0; zone < (INT32S)ZONENUM_PER_DIE; zone++)
	{
		if (sdi->ValidZoneTblFlag[zone])
			continue;

		szi = &sdi->ZoneInfos[zone];

		ZoneInFlash = ZONENO_IN_FLASH(sdi->DieNo, zone);
		sublk = NandDevInfo.ZoneInfo[ZoneInFlash].PhyBlkNum;
		page =  NandDevInfo.ZoneInfo[ZoneInFlash].TablePosition;

		if (page != 0x0fff)
			page += ZONETBL_PAGE_CNT;
		else
			page = 0;

		if (page >= (INT32S)PAGES_PER_SUBLK)
		{
			/* block is full, erase it */
			ret = SuBlkErase(sdi->DieNo, sublk);
			if (ret != TRUE)
			{
				DMSG(DBL_WARNING, "[SCAN] %s: Failed to erase zone table %u in Die %d, ret %d\n",
						__FUNCTION__, sublk, sdi->DieNo, ret);

				SuBlkMarkBad(sdi->DieNo, sublk);
				/* try again */
				return SCAN_ERR_TRY_AGAIN;
			}
			page = 0;
		}

                //DMSG(DBL_INFO, "[SCAN] %s: write zone table for zone %u to SuBlk %u Page %d in Die %d.\n",
                //	__FUNCTION__, zone, sublk, page, sdi->DieNo);
		INIT_BOOT( "[SCAN] %s: write zone table for zone %u to SuBlk %u Page %d in Die %d.\n",
				__FUNCTION__, zone, sublk, page, sdi->DieNo);
		
#if 0
		printf("Start Delay\n");
		bPrintFlag =0x01;
		//_Short_DelayUS(1000*1000);

		for(iLoop=page;iLoop<page+8;iLoop++)
		{
			ret = SuBlkPageRead(sdi->DieNo, sublk, iLoop, 0xF, GPageBuf, NULL);
			Dump_mem(GPageBuf,64,0,2);
		}
		bPrintFlag =0x00;
#endif		
		/* set the zone table data to write */
#if _NEW_ZONE_TBL_==0x01
		TblSize = (BLK_NUM_PER_ZONE - 1) * sizeof(INT32U);
		MEMCPY(GPageBuf, &szi->ZoneTbl, TblSize);
		*(INT32U *)&GPageBuf[TBL_CHKSUM_OFF_4K] =
				_GetCheckSum32((INT32U *)GPageBuf, TblSize / sizeof(INT32U));

#else
		TblSize = (BLK_NUM_PER_ZONE - 1) * sizeof(INT16U);
		MEMCPY(GPageBuf, (INT8S*)&szi->ZoneTbl, TblSize);
		*(INT16U *)&GPageBuf[TBL_CHKSUM_OFF_2K] =
				_GetCheckSum((INT16U *)GPageBuf, TblSize / sizeof(INT16U));
#endif
		/* set the spare data of zone table page */
		MEMSET((INT8U *)&SData, 0xff, sizeof(struct NandSpareData));

          
		SData.UserData[0].SpareData1.LogStatus.PhyPageStatus = PAGE_STATE_USED;
		if (page == 0)
		{
			SData.UserData[0].SpareData0.LogicBlkInfo =
			BLOCK_TYPE_SPECIAL | (zone << 10) | BLOCK_TYPE_ZONETBL;
		}
             
        
               
		bitMap = SECTOR_BITMAP_FULLPLANE;           

		/* write zone table */
		INIT_BOOT("bitMap:%x,SECTOR_NUM_PER_SINGLE_PAGE:%x\n",bitMap,SECTOR_NUM_PER_SINGLE_PAGE);
		//Str_printf(" ",(INT8U *)&SData,sizeof( struct NandSpareData));
		///   Dump_mem(GPageBuf,2048,0,2);  
	
		//bPrintFlag =0x01;
		ret = SuBlkPageWrite(sdi->DieNo, sublk, page + ZONETBL_OFFSET, bitMap, GPageBuf, &SData);
		if (ret != TRUE)
		{
			DMSG(DBL_WARNING, "[SCAN] %s: Failed to write zone table at SuBlk %u Page %d in Die %d, ret %d\n",
						__FUNCTION__, sublk, page, sdi->DieNo, ret);

			SuBlkMarkBad(sdi->DieNo, sublk);

			/* try again */
			ret = SCAN_ERR_TRY_AGAIN;
			goto out;
		}

#if NAND_SHARE_PAGES == 0x01 // added by jjf for shared page
       		INIT_BOOT("ScanWriteZoneTbls:Write zone tbl second:die:%d blk:%d page:%d bitmap:0x%x \n",\
		sdi->DieNo,sublk,page + ZONETBL_OFFSET_BACK_UP,bitMap);
               ret = SuBlkPageWrite(sdi->DieNo, sublk, page + ZONETBL_OFFSET_BACK_UP, bitMap, GPageBuf, &SData);
		if (ret != TRUE)
		{
			DMSG(DBL_WARNING, "[SCAN] %s: Failed to write zone table at SuBlk %u Page %d in Die %d, ret %d\n",
						__FUNCTION__, sublk, page, sdi->DieNo, ret);

			SuBlkMarkBad(sdi->DieNo, sublk);

			/* try again */
			ret = SCAN_ERR_TRY_AGAIN;
			goto out;
		}
#endif
        
#if _NEW_ZONE_TBL_==0x01  		
		if(SECTOR_NUM_PER_SINGLE_PAGE ==Page_Size2K) //Page 2KB 
		{
			ret = SuBlkPageWrite(sdi->DieNo, sublk, page + ZONETBL_OFFSET+1, bitMap, GPageBuf+2048, &SData);
			if (ret != TRUE)
			{
				DMSG(DBL_WARNING, "[SCAN] %s: Failed to write zone table at SuBlk %u Page %d in Die %d, ret %d\n",
					__FUNCTION__, sublk, page, sdi->DieNo, ret);

				SuBlkMarkBad(sdi->DieNo, sublk);

				/* try again */
				ret = SCAN_ERR_TRY_AGAIN;
				goto out;
			}
		}
#endif	
		if(bPrintFlag ==0x01)
		{	
		//	ECC_Err("run to :%s,%d\n",__func__,__LINE__);
		//	Print_msg();
		}
		/*2008-3-20	add read zonetbl function. */
		//ret = SuBlkPageRead(sdi->DieNo, sublk, page + ZONETBL_OFFSET, SECTOR_BITMAP_FULLPLANE, GPageBuf, &SData);
		/**/
		ret = SuBlkPageRead(sdi->DieNo, sublk, page + ZONETBL_OFFSET, 0x0f, GPageBuf, NULL);

		/* set the log block table data to write */
		TblSize = MAX_LOG_BLK_NUM *  sizeof(struct LogBlkTblType);
		MEMSET(GPageBuf, 0xff, 2*1024);
		MEMCPY(GPageBuf,(INT8S*) &szi->LogBlkTbl, TblSize);
		*(INT16U *)&GPageBuf[TABLE_CHKSUM_OFFSET] =  _GetCheckSum((INT16U *)GPageBuf, TblSize / sizeof(INT16U));

		/* set the spare data of log block table page */
		MEMSET(&SData, 0xff, sizeof(struct NandSpareData));
	//#if BREC_DRIVER ==0x01
		//printf("Start Delay\n");
		//bPrintFlag =0x01;
		//_Short_DelayUS(1000*3000);
	//#endif
		//printf("\n## run to :%s,%d\n",__func__,__LINE__);

		SData.UserData[0].SpareData1.LogStatus.PhyPageStatus = PAGE_STATE_USED;

                /// Str_printf(" ",(INT8U *)&SData,sizeof( struct NandSpareData));
 		//Dump_mem(GPageBuf,2048,0,2);
                  /*write log block table */
		ret = SuBlkPageWrite(sdi->DieNo, sublk, page + LOGTBL_OFFSET, SECTOR_BITMAP_FULLPLANE, GPageBuf, &SData);
		if (ret != TRUE)
		{
			DMSG(DBL_WARNING, "[SCAN] %s: Failed to write zone table at SuBlk %u Page %d in Die %d, ret %d\n",
				__FUNCTION__, sublk, page, sdi->DieNo, ret);

			SuBlkMarkBad(sdi->DieNo, sublk);

			/* try again */
			if (WriteRetryTImes <  4)
			{
				ret = SCAN_ERR_TRY_AGAIN;
				WriteRetryTImes++;
			}
			goto out;
		}
		//bPrintFlag =0x01;
		ret = SuBlkPageRead(sdi->DieNo, sublk, page + LOGTBL_OFFSET, 0xf, GPageBuf, NULL);
		///Dump_mem(GPageBuf,2048,0,2);
		///printf("\n## run to :%s,%d\n",__func__,__LINE__);
		NandDevInfo.ZoneInfo[ZoneInFlash].TablePosition = page;
	}
out:
	DMSG(DBL_LOG, "[SCAN] %s(DieNo: %d): out, ret %d.\n", __FUNCTION__, sdi->DieNo, ret);

        return ret;
}

static inline INT32S check_all_ff(const void *buf, INT32S size)
{
	INT32S i;

	for (i = 0; i < (INT32S)(size / sizeof(INT32U)); i++)
		if (((const INT32U *)buf)[i] != ~((INT32U)0))
			return 0;

	for (i = i; i < size; i++)
		if (((const INT8U *) buf)[i] != 0xFF)
			return 0;

	return 1;
}

static INT32U CheckZoneTbl(struct ScanDieInfo *sdi, INT32U zone)
{
	struct ScanZoneInfo *szi;
	struct NandSpareData SData;
	struct LogBlkTblType *plogblk;
	INT32S LogBlk, LogBlkAge, DataBlk, DataBlkAge, LogicalBlk;
	INT32S i, ret, LastUsedPage;
	INT16U LogicalBlkInfo;

	DMSG(DBL_LOG, "[SCAN] %s(zone: %u): enter.\n", __FUNCTION__, zone);

	szi = &sdi->ZoneInfos[zone];

#if 0
	dump_mem(&szi->ZoneTbl, 2048, 0, 2);
	dump_mem(&szi->LogBlkTbl, 48, 0, 2);
#endif

	/* check log blocks */
	for (i = 0; i < MAX_LOG_BLK_NUM; i++)
	{
		plogblk = &szi->LogBlkTbl[i];
		LogBlk = plogblk->PhyBlkNum.PhyBlkNum;

		/* skip nil log block */
		if (LogBlk == 0xfff)
			continue;

		/* check the logical block number limits */
		if (plogblk->LogicBlkNum >= DATA_BLK_NUM_PER_ZONE)
		{
			DMSG(DBL_WARNING, "%s: Logical block %u of log block %u exceeds limit\n",
				__FUNCTION__, plogblk->LogicBlkNum, LogBlk);
		}

		/* get the last used page of log block */
		LastUsedPage = -1;
		GetLastUsedPage(sdi->DieNo, LogBlk, &LastUsedPage);

		/* check the last used page of log block */
		if (plogblk->LastUsedPage != LastUsedPage)
		{
			DMSG(DBL_WARNING, "%s: Log block %u claims its lastusedpage is %u, but in fact the page is %u\n",
				__FUNCTION__, LogBlk, plogblk->LastUsedPage, LastUsedPage);
		}

		/* read log block info */
		ret = SuBlkPageRead(sdi->DieNo, LogBlk, 0, SECTOR_BITMAP_SPAREDATA, GPageBuf, &SData);
		if (ret != TRUE)
		{
			/*  */
		}

#if 0
		if (check_all_ff(GPageBuf, 2 * 512))
		{
			DMSG(DBL_LOG, "%s: The former 2 sector of log block %u IS all 0xff\n",
				__FUNCTION__, LogBlk);
		}
		else
		{
			DMSG(DBL_LOG, "%s: The former 2 sector of log block %u is NOT all 0xff\n",
				__FUNCTION__, LogBlk);
			//dump_mem(GPageBuf, 2 * 512, 0, 1);
		}
#endif

		DMSG(DBL_LOG, "%s: Log block %u (logical block %u) spare data:\n",
			__FUNCTION__, LogBlk, plogblk->LogicBlkNum);
		//Dump_mem(&SData, 12, 0, 1);


		LogicalBlkInfo = SData.UserData[0].SpareData0.LogicBlkInfo;
		LogicalBlk = GetLogBlockNum(LogicalBlkInfo);
		LogBlkAge = SData.UserData[0].SpareData1.LogStatus.LogBlkAge;
	
		/* check the zone number of log block */
		if (GetZoneTblNum(LogicalBlkInfo) !=(INT16U) zone)
		{
			DMSG(DBL_WARNING, "%s: Log block %u in zone %u claims it belongs to zone %u\n",
				__FUNCTION__, LogBlk, zone, GetZoneTblNum(LogicalBlkInfo));
		}

		/* check the zone number of log block */
		if (LogicalBlk != plogblk->LogicBlkNum)
		{
			DMSG(DBL_WARNING, "%s: Log block %u (logical block %u) claims it belongs to logical block %u\n",
				__FUNCTION__, LogBlk, LogicalBlk, plogblk->LogicBlkNum);
		}

		/* read data block info */
	//	DataBlk = ((struct DataBlkTblType *)&szi->ZoneTbl[LogicalBlk])->PhyBlkNum;
		DataBlk = ((struct DataBlkTblType *)&szi->ZoneTbl[plogblk->LogicBlkNum])->PhyBlkNum;

		ret = SuBlkPageRead(sdi->DieNo, DataBlk, 0, SECTOR_BITMAP_SPAREDATA, GPageBuf, &SData);
		if (ret != TRUE)
		{
			/*  */
		}

		if (check_all_ff(GPageBuf, 2 * 512))
		{
			DMSG(DBL_LOG, "%s: The former 2 sector of data block %u is all 0xff\n",
				__FUNCTION__, DataBlk);
		}

		DMSG(DBL_LOG, "%s: Data block %u (logical block %u) spare data:\n",
			__FUNCTION__, DataBlk, LogicalBlk);
//		dump_mem(&SData, 12, 0, 1);

		/* check the age sequence */
	
		DataBlkAge = SData.UserData[0].SpareData1.LogStatus.LogBlkAge;

		if (LogBlkAge != SEQ_NEXT(DataBlkAge))
		{
			DMSG(DBL_WARNING, "%s: Log block %u age %u is not sequential with data block %u age %u, LogicalBlk %u\n",
				__FUNCTION__, LogBlk, LogBlkAge, DataBlk, DataBlkAge, LogicalBlk);
		}

	}

	DMSG(DBL_LOG, "[SCAN] %s(zone: %u): out.\n", __FUNCTION__, zone);

	return TRUE;
}

/**
 * \brief  Read a valid zone table from flash
 *
 * This routine reads a zone table by postion infomation at the <NandDev.ZonInfo>,
 * and don't check the validation of the zone table.
 *
 * \param[in]  sdi The ScanDieInfo Pointer of die
 * \param[in]  zone The zone number that need be read
 *
 * \return  the search result
 *  - TRUE  Succeeded to read zone table
 *  - FALSE  Failed to read zone table
 *  - FALSE|ECCERROR  the ecc error;
 *  - FALSE|ADDRERROR  the address is invalid;
 */
static INT32U DbgScanCheckZoneTbl(struct ScanDieInfo *sdi)
{
	INT32S zone;

	DMSG(DBL_LOG, "[SCAN] %s(zone: %u): enter.\n", __FUNCTION__, zone);

	ScanInitMemory(sdi);

	for (zone = 0; zone < (INT32S)ZONENUM_PER_DIE; zone++)
	{
		/* save original valid flag */
		INT32S valid_flag = sdi->ValidZoneTblFlag[zone];

		sdi->ValidZoneTblFlag[zone] = 1;

		/* read the zone table from flash */
		ScanReadZoneTbl(sdi, zone);

		/* restore original valid flag */
		sdi->ValidZoneTblFlag[zone] = valid_flag;

		CheckZoneTbl(sdi, zone);
	}

	ScanFreeMemory(sdi);

	DMSG(DBL_LOG, "[SCAN] %s(zone: %u): out.\n", __FUNCTION__, zone);

	return TRUE;
}


/**
 * \brief  Rebiuld the zone tables which cannot be found or checksum error in the die.
 *
 * This routine rebuilds the zone tables for a die.
 * a) Reads all physical blocks infomation.
 * b) Fills the zone tables except the valid zones.
 * c) Removes the free blocks that already allocated to the valid zones.
 * d) Allocates the zone tabled block in zone table block area if needed.
 * e) Checks page-mapping table of each log block of zone, and rebuild it if not found.
 * f) Distributes the free blocks averagely for each zone.
 * g) Writes the zone tables to flash.
 *
 * \param[in]  sdi The ScanDieInfo Pointer of die which need rebuild zone tables
 *
 * \return  the rebuilding result
 *  - TRUE:  Succeeded to rebuild zone tables
 *  - FALSE:  Failed to rebuild zone tables
 *  - SCAN_ERR_TRY_AGAIN: Try again and maybe it will be sucess.
 */
static INT32U ScanRebuildZoneTbls(struct ScanDieInfo *sdi)
{
	INT32U ret, DieNo;

	DMSG(DBL_LOG, "[SCAN] ScanRebuildZoneTbls(DieNo: %u) enter.\n", sdi->DieNo);

	DASSERT(sdi->DieNo < MAX_ZONE_NUM_IN_DIE);
	DieNo = sdi->DieNo;
	/* step1: allocate memory for rebuilding */
	ret = ScanInitMemory(sdi);
	if (ret != TRUE) {
		DMSG(DBL_ERR, "[SCAN] ScanInitMemory() failed for die %d, ret %d\n", DieNo, ret);
		goto failed;
	}
	/* step2: read all blocks info to <scan_die_info> */
	ret = ScanReadDieBlkInfo(sdi);
	if (ret != TRUE) {
		DMSG(DBL_ERR, "[SCAN] ScanReadDieBlkInfo() failed for die %d, ret %d\n", DieNo, ret);
		goto failed;
	}
	/* step3: fill zonetbls by <scan_die_info> */
	ret = ScanFillZoneTbls(sdi);
	if (ret != TRUE) {
		DMSG(DBL_ERR, "[SCAN] ScanFillZoneTbls() failed for die %d, ret %d\n", DieNo, ret);
		goto failed;
	}
	/* step4: remove the allocated free blocks from <ScanDieInfo> */
	ret = ScanRemoveAllocatedFreeBlks(sdi);
	if (ret != TRUE) {
		DMSG(DBL_ERR, "[SCAN] ScanRemoveAllocatedFreeBlks() failed for die %d, ret %d\n", DieNo, ret);
		goto failed;
	}
	/* init the last free block index to the first block of die */
	sdi->LastFreeBlk = DIE_FIRST_SUBLK_NUM;
	/* step5: check zone table postion, ensure they locate in the beginning position of flash */
	ret = ScanAllocatedZoneTblBlks(sdi);
	if (ret != TRUE) {
		DMSG(DBL_ERR, "[SCAN] ScanAllocatedZoneBlks() failed for die %d, ret %d\n", DieNo, ret);
		goto failed;
	}
	/* step6: build group tables for zones which need to be rebuilt */
	ret =ScanCheckPageMappingTbls(sdi);
	if (ret != TRUE) {
		DMSG(DBL_ERR, "[SCAN] ScanCheckPageMappingTbls() failed for die %d, ret %d\n", DieNo, ret);
		goto failed;
	}

	/* step7: Distribute free blocks to zone tables */
	ret =ScanDistributeFreeBlks(sdi);
	if (ret != TRUE) {
		DMSG(DBL_ERR, "[SCAN] ScanDistributeFreeBlks() failed for die %d, ret %d\n", DieNo, ret);
		goto failed;
	}

	/* step8: caculate zonetable checksum & write it to flash. */
	ret =ScanWriteZoneTbls(sdi);
	if (ret != TRUE) {
		DMSG(DBL_ERR, "[SCAN] ScanWriteZoneTbls() failed for die %d, ret %d\n", DieNo, ret);
		goto failed;
	}

#ifdef DBG_DUMP_ZONE_TBLS
	DbgDumpZoneTbls(sdi);
#endif

	ret = TRUE;
failed:
	/* step9: free memory */
	ScanFreeMemory(sdi);

	//DMSG(DBL_LOG, "[SCAN] ScanRebuildZoneTbls(DieNo: %u), ret %u\n",DieNo, ret);
	INIT_BOOT( "[SCAN] ScanRebuildZoneTbls(DieNo: %u), ret %u\n",DieNo, ret);
	return ret;
}
#if   _TEST_HW_PageCTL_ && FWSC_DRIVER==0x01

INT8U Const_Data[8192]=
{
#if BREC_DRIVER ==0x00
0x81, 0xd1, 0x3e, 0xf9, 0x0a, 0x73, 0x3a, 0x5c, 0xb4, 0xc0, 0x8e, 0x5d, 0xfd, 0xb2, 0xc0, 0x0a,   /*  15*/
0xd0, 0x09, 0x44, 0xa4, 0x92, 0x6d, 0xb8, 0x6e, 0xae, 0xd1, 0xd8, 0x47, 0xbb, 0x3b, 0xd9, 0x76,   /*  31*/
0xd8, 0x43, 0x75, 0xde, 0xea, 0xa7, 0xdc, 0xde, 0x3d, 0x35, 0x67, 0xa0, 0xc4, 0xff, 0xfb, 0x90,   /*  47*/
0x60, 0xd2, 0x00, 0x03, 0x43, 0x3d, 0xdc, 0xe9, 0xed, 0x42, 0xe8, 0x5d, 0xa7, 0x1b, 0x9d, 0x2d,   /*  63*/
0x67, 0x5b, 0x0c, 0xfc, 0xf5, 0x6b, 0x87, 0x9d, 0x0b, 0xa9, 0x5e, 0x0f, 0xee, 0xf4, 0xa1, 0xa5,   /*  79*/
0x24, 0xde, 0xf6, 0xbe, 0xeb, 0xa4, 0x5b, 0x5f, 0x4d, 0xae, 0x94, 0x21, 0x7a, 0x6a, 0x19, 0x87,   /*  95*/
0x5c, 0xb3, 0x91, 0xe3, 0x4a, 0x92, 0x3a, 0xb3, 0xf2, 0x01, 0x1e, 0xcc, 0x43, 0xba, 0x0a, 0x12,   /* 111*/
0xd5, 0x60, 0xe9, 0x89, 0x8b, 0x8a, 0x33, 0xa6, 0xea, 0xea, 0x2d, 0x52, 0x49, 0xb8, 0x8b, 0xa6,   /* 127*/
0xe5, 0x47, 0xcd, 0x9d, 0xff, 0xad, 0xcc, 0x7c, 0xeb, 0x8e, 0x3a, 0x9e, 0x45, 0x9c, 0xb9, 0x08,   /* 143*/
0xce, 0x52, 0xa9, 0x15, 0xcc, 0x8c, 0xc9, 0x59, 0x8b, 0x42, 0xdd, 0x1a, 0xe9, 0x71, 0x01, 0xc1,   /* 159*/
0x87, 0xee, 0x03, 0xcd, 0xb4, 0xd3, 0x4d, 0x25, 0x37, 0x8a, 0x26, 0x81, 0xe1, 0xe2, 0x3a, 0xbc,   /* 175*/
0xa6, 0x02, 0x82, 0x4a, 0x3e, 0x56, 0x4c, 0x18, 0x32, 0xe0, 0x33, 0xb3, 0x1f, 0xb1, 0x4b, 0x3e,   /* 191*/
0x52, 0xdf, 0xbc, 0xce, 0x82, 0xae, 0xaa, 0x26, 0x5a, 0xf5, 0xf2, 0x7e, 0x5f, 0x43, 0xd8, 0x0f,   /* 207*/
0xa8, 0x4f, 0xcd, 0x6d, 0x8d, 0xe4, 0x09, 0xa5, 0xb8, 0x00, 0x36, 0x66, 0x5f, 0x3f, 0x6e, 0xbe,   /* 223*/
0x52, 0x2e, 0xa3, 0x3c, 0xf5, 0x86, 0xf4, 0x07, 0xb2, 0x87, 0x7d, 0x1f, 0x25, 0x77, 0xe9, 0x1e,   /* 239*/
0x73, 0xff, 0xf0, 0x80, 0xff, 0x76, 0xfb, 0xc2, 0x26, 0x91, 0x12, 0x45, 0x43, 0xaa, 0xa5, 0xb1,   /* 255*/
0x20, 0x3e, 0x7e, 0x44, 0xe5, 0x08, 0x84, 0x7b, 0x17, 0x87, 0x7b, 0x4d, 0xbc, 0xe5, 0x63, 0xdd,   /* 271*/
0xde, 0xf3, 0x58, 0xda, 0x03, 0x8f, 0x43, 0xcd, 0xec, 0x8b, 0x7d, 0xad, 0x17, 0x16, 0xbd, 0x89,   /* 287*/
0x9f, 0xcf, 0x38, 0x8a, 0x5f, 0xb4, 0x63, 0xb9, 0x99, 0x87, 0x2d, 0xe4, 0x61, 0xe1, 0x57, 0xbf,   /* 303*/
0x8f, 0x32, 0xfb, 0xd5, 0xfc, 0xfb, 0x0d, 0xac, 0x72, 0xb9, 0x9f, 0xfd, 0xe9, 0x5f, 0xff, 0xcf,   /* 319*/
0x2b, 0x29, 0xe5, 0x22, 0x33, 0x23, 0x47, 0x40, 0xb4, 0x08, 0xd5, 0x60, 0x41, 0x2c, 0xcb, 0x49,   /* 335*/
0x09, 0x0c, 0xa4, 0x37, 0x84, 0xe1, 0x0e, 0x11, 0x58, 0x33, 0xc7, 0x2d, 0x49, 0x5e, 0x24, 0x07,   /* 351*/
0x59, 0x00, 0x75, 0x33, 0x2b, 0xba, 0xab, 0xfc, 0x0c, 0x0d, 0x00, 0x23, 0x60, 0x28, 0x15, 0xfe,   /* 367*/
0x7b, 0x22, 0x58, 0x53, 0x08, 0xdd, 0x9f, 0x59, 0x75, 0x7d, 0xd7, 0x52, 0xa9, 0x64, 0xfe, 0x93,   /* 383*/
0xb3, 0xbd, 0xad, 0x50, 0xef, 0x57, 0x9f, 0x31, 0xef, 0x36, 0x5f, 0x32, 0x72, 0x9c, 0xbc, 0xbb,   /* 399*/
0x25, 0x5e, 0xaf, 0x33, 0xac, 0x72, 0x58, 0xaa, 0x7d, 0x0d, 0xab, 0xb2, 0xaa, 0x51, 0xc1, 0x4a,   /* 415*/
0x7a, 0x35, 0x7a, 0xaf, 0xb9, 0x1d, 0xca, 0x11, 0x97, 0x07, 0x1c, 0x1a, 0x3c, 0x35, 0x82, 0xc2,   /* 431*/
0xeb, 0xa8, 0xaa, 0xba, 0xd6, 0x09, 0xd6, 0x49, 0x20, 0x82, 0x88, 0x32, 0x79, 0x7d, 0x00, 0xcd,   /* 447*/
0x0c, 0xfc, 0x71, 0x47, 0xdd, 0x3e, 0x0e, 0xab, 0xc7, 0xfb, 0x47, 0x07, 0x02, 0x37, 0xff, 0xfb,   /* 463*/
0x90, 0x60, 0xcd, 0x80, 0x03, 0x6b, 0x64, 0x5a, 0xe9, 0xeb, 0x2b, 0x62, 0x57, 0x24, 0x0b, 0x9d,   /* 479*/
0x2c, 0x42, 0x49, 0x4c, 0xf1, 0x75, 0x71, 0xc6, 0x28, 0x6d, 0xa9, 0x57, 0xa7, 0xae, 0x78, 0x91,   /* 495*/
0x09, 0xb4, 0x6f, 0xbe, 0x5e, 0xe1, 0x40, 0x5d, 0x7e, 0xd5, 0x3f, 0x8a, 0xd3, 0x8f, 0x87, 0x10,   /* 511*/
0x87, 0x5c, 0xdb, 0x7a, 0x8f, 0xeb, 0x8d, 0xe9, 0x5f, 0x76, 0x7f, 0x99, 0x9f, 0xef, 0x6d, 0xff,   /* 527*/
0x1b, 0x31, 0xca, 0xfc, 0xed, 0xa6, 0xf3, 0x2d, 0xe3, 0xb6, 0xed, 0xfe, 0xf0, 0xcc, 0x8e, 0xef,   /* 543*/
0x78, 0x79, 0xc8, 0xee, 0xee, 0xdb, 0xef, 0x1d, 0xb3, 0xe6, 0x3b, 0x6f, 0xf5, 0x57, 0xde, 0x33,   /* 559*/
0x6a, 0x32, 0x8f, 0x3f, 0xdd, 0x9a, 0x75, 0x42, 0xee, 0x1c, 0xcc, 0xca, 0xba, 0xc5, 0xc1, 0xd0,   /* 575*/
0x78, 0xa8, 0x41, 0x5b, 0x77, 0x22, 0x0d, 0xad, 0xdb, 0xd4, 0x3e, 0xf0, 0x76, 0xd8, 0xaa, 0xba,   /* 591*/
0xf9, 0xd0, 0x6c, 0x72, 0xb8, 0x47, 0x1a, 0x0d, 0x6e, 0x5c, 0xd9, 0x5a, 0xe3, 0x03, 0x61, 0x31,   /* 607*/
0x48, 0x8b, 0xde, 0x9f, 0xe8, 0xe7, 0xaa, 0x4f, 0xf5, 0xb7, 0x33, 0x77, 0xff, 0x90, 0xfc, 0xde,   /* 623*/
0x72, 0x91, 0x6b, 0xe4, 0xcb, 0xa7, 0x92, 0x95, 0x08, 0x05, 0xe8, 0x66, 0x6d, 0x88, 0x42, 0x28,   /* 639*/
0x75, 0xef, 0xc5, 0xcf, 0xa4, 0xbf, 0x0c, 0xcb, 0xf9, 0xf6, 0x13, 0x4b, 0xe7, 0xc4, 0x80, 0x6e,   /* 655*/
0xe1, 0xce, 0xba, 0x5d, 0x45, 0xa3, 0x81, 0x83, 0x65, 0xcb, 0x80, 0x21, 0xe1, 0xf8, 0xb1, 0xc5,   /* 671*/
0x5d, 0xfe, 0xe5, 0xd7, 0xba, 0xff, 0xb7, 0xc8, 0xfb, 0x40, 0x10, 0x48, 0x25, 0x24, 0x9b, 0x70,   /* 687*/
0x73, 0x21, 0x50, 0x3e, 0x8c, 0x80, 0x1f, 0xb9, 0xc5, 0xf4, 0xdc, 0xaa, 0x94, 0x99, 0x09, 0x85,   /* 703*/
0x4f, 0xa7, 0x98, 0xe3, 0xf8, 0x13, 0x5a, 0x74, 0x48, 0x9a, 0x78, 0xe7, 0x7f, 0x56, 0xb5, 0x10,   /* 719*/
0x07, 0x74, 0xdf, 0xbd, 0xbd, 0x5b, 0x17, 0x7e, 0x0d, 0x0e, 0xff, 0x14, 0x9f, 0xb2, 0x17, 0x18,   /* 735*/
0xd8, 0xaf, 0x1c, 0xb6, 0x32, 0xfc, 0xe2, 0x52, 0xca, 0x49, 0x94, 0x32, 0xf3, 0x5c, 0xa1, 0xa6,   /* 751*/
0x66, 0xc4, 0x5e, 0x7c, 0x3b, 0xb6, 0x72, 0x22, 0x02, 0x55, 0x57, 0x32, 0x2b, 0x45, 0xba, 0xfb,   /* 767*/
0xef, 0xf1, 0xd8, 0x18, 0x57, 0xaf, 0x48, 0x1c, 0x00, 0x20, 0x4c, 0x08, 0x33, 0xae, 0x07, 0xe8,   /* 783*/
0x6c, 0x15, 0x47, 0xd4, 0x42, 0x92, 0x2d, 0x4c, 0xb7, 0x81, 0x28, 0xac, 0x4a, 0x0b, 0x60, 0xbe,   /* 799*/
0x5b, 0x16, 0xbf, 0x1a, 0x0c, 0x74, 0x7e, 0xf7, 0xcc, 0xde, 0x75, 0x74, 0x6f, 0x76, 0x57, 0x29,   /* 815*/
0x1a, 0x9c, 0xf2, 0xbf, 0x0b, 0x23, 0x3f, 0xfa, 0xff, 0xfe, 0x7f, 0x6f, 0xe7, 0xcd, 0x6f, 0xeb,   /* 831*/
0xc7, 0x56, 0xaf, 0x48, 0x8d, 0xed, 0xff, 0xe1, 0x65, 0xb9, 0x79, 0x7f, 0xce, 0x6f, 0x3b, 0x21,   /* 847*/
0x1e, 0xd1, 0x0d, 0x61, 0x12, 0xa0, 0xeb, 0xb5, 0x29, 0x21, 0x70, 0xf2, 0x86, 0x6c, 0x15, 0x48,   /* 863*/
0x4c, 0xd0, 0x35, 0xb9, 0x6d, 0x3f, 0x49, 0x7f, 0xa8, 0xaf, 0x20, 0x57, 0x34, 0x51, 0x44, 0xff,   /* 879*/
0xfb, 0x90, 0x60, 0xcb, 0x00, 0x03, 0x87, 0x58, 0xda, 0xe1, 0xe8, 0x33, 0x6a, 0x5e, 0x0a, 0x1b,   /* 895*/
0x9c, 0x30, 0xa3, 0x6d, 0x4d, 0x4d, 0x73, 0x6f, 0xa6, 0x20, 0x6d, 0x89, 0x61, 0xac, 0xae, 0xb0,   /* 911*/
0xa2, 0x8d, 0xb5, 0x8a, 0xa8, 0x30, 0x1e, 0xc0, 0x05, 0x3e, 0x07, 0x8f, 0xae, 0x06, 0xe8, 0x2a,   /* 927*/
0x25, 0x65, 0xb9, 0x27, 0x99, 0x0c, 0x00, 0x59, 0x9b, 0xa4, 0xb4, 0x94, 0xb7, 0x46, 0x9a, 0x49,   /* 943*/
0x6d, 0x50, 0xe4, 0x53, 0x22, 0xb4, 0xde, 0x85, 0x04, 0xa5, 0xf4, 0x1d, 0x06, 0x37, 0xa7, 0xbe,   /* 959*/
0xb2, 0xc2, 0xae, 0xc7, 0x50, 0xa5, 0xfc, 0xe9, 0xe5, 0x20, 0xb2, 0x56, 0x3f, 0xfc, 0xfc, 0xf3,   /* 975*/
0xf7, 0x2e, 0x6b, 0xf4, 0xbb, 0xf3, 0x3f, 0xdb, 0x87, 0xfd, 0x2c, 0xb3, 0x9e, 0x9c, 0xd5, 0x96,   /* 991*/
0x25, 0x1d, 0xac, 0x7b, 0x2f, 0xc8, 0x16, 0x18, 0x95, 0x07, 0x56, 0x6c, 0x1d, 0xd4, 0x5a, 0x00,   /*1007*/
0xd1, 0xbe, 0xdc, 0x5d, 0xfe, 0x49, 0x5d, 0xc1, 0xfb, 0x01, 0xa4, 0x48, 0x92, 0x83, 0x7e, 0x88,   /*1023*/
0x26, 0x06, 0xc9, 0xca, 0x81, 0xbf, 0xff, 0x74, 0x18, 0x78, 0xe8, 0x44, 0x09, 0x8b, 0xce, 0x67,   /*1039*/
0x55, 0x53, 0x3d, 0x59, 0x5c, 0xd2, 0xee, 0xc9, 0x53, 0xdf, 0xaa, 0x1f, 0xec, 0xfd, 0x2e, 0x96,   /*1055*/
0xa3, 0x75, 0x37, 0xd0, 0xbf, 0xec, 0x96, 0x66, 0x3b, 0xd1, 0xf4, 0xbe, 0x4b, 0xa5, 0x52, 0xe9,   /*1071*/
0x33, 0x5f, 0xd3, 0x7b, 0xf7, 0xb2, 0x49, 0x23, 0x14, 0x53, 0x21, 0x0e, 0x06, 0xe7, 0x10, 0xa7,   /*1087*/
0x08, 0x57, 0x44, 0x65, 0x3b, 0xa1, 0x4e, 0x6a, 0x1d, 0x2f, 0x5a, 0xa3, 0xb0, 0x81, 0x0e, 0x62,   /*1103*/
0x9a, 0xeb, 0xcd, 0x18, 0x81, 0x45, 0x24, 0xb4, 0xaa, 0xc4, 0xf0, 0x40, 0xd1, 0x91, 0x9e, 0x17,   /*1119*/
0xc0, 0x95, 0xbe, 0xcf, 0xc2, 0xa9, 0x1d, 0xc8, 0xbe, 0x52, 0x81, 0x44, 0x6a, 0xbe, 0xa8, 0x47,   /*1135*/
0x90, 0x08, 0xdf, 0x20, 0xe6, 0x7d, 0x62, 0x1a, 0x49, 0x1f, 0x9f, 0xde, 0xb6, 0x18, 0x42, 0x3e,   /*1151*/
0xc4, 0x3e, 0xb4, 0xe0, 0x64, 0xee, 0xea, 0x7c, 0x55, 0xfb, 0xff, 0xa2, 0xf4, 0xc8, 0x27, 0x2f,   /*1167*/
0xf7, 0x32, 0x70, 0xaf, 0x78, 0x61, 0xfc, 0x8f, 0x67, 0x24, 0x44, 0x64, 0xf3, 0xbc, 0x06, 0xe3,   /*1183*/
0xbf, 0x4a, 0x5e, 0xe5, 0xad, 0x4d, 0x62, 0xb1, 0xfc, 0xbe, 0xb6, 0x34, 0xd7, 0xab, 0xac, 0xbb,   /*1199*/
0x37, 0xf1, 0xfe, 0xfe, 0x09, 0x41, 0xba, 0x19, 0x99, 0x1a, 0x6d, 0xb6, 0x93, 0x9f, 0x23, 0x00,   /*1215*/
0x3d, 0x11, 0x3c, 0x83, 0x25, 0xd4, 0x21, 0x26, 0x33, 0x23, 0x53, 0x70, 0x30, 0x7a, 0xcf, 0xe6,   /*1231*/
0x8c, 0xcf, 0xf2, 0x31, 0xb2, 0xfe, 0x8f, 0xf8, 0xed, 0x2b, 0x7a, 0xfb, 0x51, 0x0f, 0x57, 0x74,   /*1247*/
0x6f, 0xeb, 0xab, 0xed, 0x67, 0xdd, 0xbc, 0x85, 0x3e, 0x64, 0x53, 0x6d, 0x34, 0xad, 0x6c, 0xac,   /*1263*/
0xa6, 0xa1, 0x0d, 0xd7, 0xa7, 0xd2, 0x92, 0xfe, 0x8a, 0xb5, 0x62, 0x91, 0xc8, 0x63, 0x02, 0x06,   /*1279*/
0x73, 0x94, 0x90, 0xba, 0x19, 0x20, 0xd4, 0x64, 0xb3, 0xa2, 0x4a, 0x29, 0x06, 0x81, 0x62, 0xa9,   /*1295*/
0xff, 0xfb, 0x90, 0x60, 0xc0, 0x80, 0x03, 0x44, 0x54, 0x5c, 0xe1, 0x2d, 0x1b, 0x6a, 0x5b, 0x4b,   /*1311*/
0x8b, 0x9c, 0x24, 0xe2, 0x6d, 0x4c, 0x2c, 0x7d, 0x77, 0x87, 0xb0, 0xc9, 0x29, 0x85, 0x2d, 0x6f,   /*1327*/
0xbc, 0x93, 0x09, 0xb5, 0xf0, 0xda, 0xca, 0xf2, 0x5f, 0xa0, 0x68, 0xa3, 0x11, 0x69, 0x24, 0x91,   /*1343*/
0x44, 0x9a, 0xd8, 0x02, 0x82, 0x5c, 0x15, 0x31, 0xd2, 0x67, 0x65, 0x95, 0xfa, 0x79, 0x49, 0x51,   /*1359*/
0x1f, 0x1f, 0xd1, 0x6d, 0x1e, 0xa8, 0x72, 0xcd, 0x9f, 0x38, 0x63, 0x72, 0x69, 0x24, 0x87, 0xde,   /*1375*/
0xfb, 0xf5, 0x79, 0xb9, 0x63, 0xe2, 0x0a, 0xa2, 0x32, 0xa1, 0xcc, 0x11, 0x3d, 0x65, 0x81, 0xf4,   /*1391*/
0x71, 0x81, 0xf2, 0x35, 0xe4, 0x72, 0x7d, 0xb7, 0x33, 0x2b, 0x39, 0x8b, 0x7b, 0xda, 0xa8, 0xbd,   /*1407*/
0x1d, 0x94, 0xc7, 0x46, 0x7d, 0xdd, 0x4e, 0xc5, 0x71, 0xce, 0x61, 0x82, 0xc5, 0x21, 0xc8, 0xaa,   /*1423*/
0x8e, 0x28, 0x90, 0x93, 0xd4, 0x54, 0x1b, 0x16, 0x63, 0x9e, 0x86, 0x0f, 0xfe, 0x59, 0x0c, 0xa1,   /*1439*/
0xc0, 0x54, 0x5c, 0xba, 0xf5, 0x95, 0x94, 0xad, 0x36, 0xd2, 0x6d, 0xb2, 0xa7, 0xf7, 0x18, 0x9e,   /*1455*/
0x06, 0x48, 0x30, 0x66, 0x8c, 0xa6, 0x0b, 0x4e, 0x5f, 0x96, 0xb4, 0xa9, 0x59, 0x51, 0x0a, 0x25,   /*1471*/
0x21, 0xae, 0xfd, 0xd9, 0x2a, 0x8e, 0x94, 0x63, 0x96, 0x98, 0xf5, 0xa4, 0x89, 0x27, 0xf6, 0xa7,   /*1487*/
0x5d, 0xfe, 0x9a, 0xdd, 0x32, 0xa6, 0xf3, 0x0a, 0xd6, 0x69, 0x3f, 0xf9, 0xb2, 0x0a, 0xb2, 0x32,   /*1503*/
0xd2, 0x2d, 0xa7, 0x52, 0x02, 0x79, 0xb0, 0xe8, 0xc5, 0xeb, 0x00, 0xf2, 0xa9, 0xd3, 0xa4, 0xd3,   /*1519*/
0x32, 0x49, 0x12, 0x09, 0xa0, 0x59, 0x9b, 0x83, 0x2c, 0x97, 0x67, 0xd4, 0x30, 0x96, 0xc8, 0x6e,   /*1535*/
0xca, 0x2d, 0x31, 0xb7, 0xe7, 0xb7, 0xac, 0x45, 0x2a, 0x18, 0x9d, 0xf8, 0xb7, 0x5c, 0xc7, 0x71,   /*1551*/
0xd5, 0xec, 0x10, 0xa8, 0x8c, 0x76, 0x8d, 0x8b, 0x24, 0x62, 0x4b, 0x88, 0xa8, 0xa2, 0xd6, 0x14,   /*1567*/
0x3e, 0xef, 0x4c, 0xb1, 0xef, 0x88, 0x22, 0x43, 0x40, 0xc2, 0xa5, 0x4a, 0x80, 0xec, 0xa8, 0x57,   /*1583*/
0x33, 0x1e, 0xaa, 0xab, 0x77, 0xb5, 0x88, 0x4d, 0xaf, 0xda, 0xfd, 0x15, 0x8e, 0x85, 0xdf, 0xc6,   /*1599*/
0xb1, 0xde, 0x61, 0x20, 0x08, 0xae, 0x87, 0x94, 0x50, 0xee, 0xa8, 0x61, 0x13, 0x4d, 0xaa, 0x11,   /*1615*/
0x8a, 0x51, 0x82, 0xe5, 0x34, 0x4b, 0x17, 0xfb, 0x1b, 0x4c, 0x6a, 0x1e, 0xd5, 0x04, 0xd3, 0xe8,   /*1631*/
0x27, 0xa6, 0x52, 0x45, 0xa4, 0x92, 0x44, 0x8f, 0x50, 0xcd, 0x2a, 0x01, 0x00, 0x34, 0x44, 0x9e,   /*1647*/
0x5c, 0xb0, 0x7e, 0xe3, 0x8e, 0xac, 0x56, 0xff, 0xf8, 0xb1, 0x8f, 0x6f, 0x6f, 0x58, 0xbb, 0x82,   /*1663*/
0xdc, 0xec, 0x45, 0xab, 0x50, 0xac, 0xf8, 0x94, 0xd9, 0x1a, 0xbe, 0xbe, 0xc9, 0xb6, 0x88, 0x9c,   /*1679*/
0x9f, 0xb7, 0x7e, 0xa4, 0x12, 0x7e, 0x21, 0xea, 0xfb, 0x0e, 0x29, 0xc2, 0x2a, 0x9c, 0xef, 0xff,   /*1695*/
0x8b, 0x87, 0x1c, 0xea, 0x81, 0x04, 0xa8, 0xdb, 0x94, 0x70, 0x76, 0x30, 0x4f, 0xa3, 0x11, 0x45,   /*1711*/
0x24, 0xff, 0xfb, 0x90, 0x60, 0xbb, 0x80, 0x03, 0x59, 0x42, 0xde, 0xeb, 0x0f, 0x2a, 0xe8, 0x48,   /*1727*/
0xc6, 0x6b, 0xfd, 0x25, 0x02, 0x5b, 0x0e, 0x45, 0x27, 0x77, 0x4c, 0x3c, 0xad, 0xa1, 0x2f, 0x19,   /*1743*/
0xef, 0x74, 0x94, 0x89, 0x6c, 0x91, 0x20, 0x9c, 0x2d, 0x07, 0x51, 0xe7, 0x77, 0x46, 0xf8, 0x53,   /*1759*/
0xc4, 0x8d, 0x97, 0x2c, 0x95, 0x74, 0xc6, 0xe5, 0x23, 0x5a, 0xd7, 0xe7, 0xdd, 0xa5, 0x6b, 0xe9,   /*1775*/
0x4a, 0xae, 0x03, 0xef, 0xd2, 0xbd, 0x03, 0x11, 0x6f, 0xd9, 0xe2, 0xe8, 0x33, 0x8e, 0xd3, 0xff,   /*1791*/
0x5b, 0x53, 0x45, 0x10, 0x68, 0x23, 0x9d, 0xa5, 0x01, 0x45, 0xdd, 0xd0, 0x88, 0x7f, 0x23, 0x90,   /*1807*/
0xe7, 0xab, 0x87, 0x09, 0xaa, 0xd5, 0x09, 0x25, 0xfd, 0xd5, 0xe9, 0xa9, 0x09, 0xd0, 0xc2, 0xeb,   /*1823*/
0xa0, 0x90, 0x0e, 0x2e, 0xfa, 0x07, 0x85, 0x19, 0xe5, 0x18, 0x26, 0xfc, 0xc3, 0x47, 0xb4, 0x4a,   /*1839*/
0x43, 0x27, 0x8a, 0x7c, 0x5a, 0x7c, 0xcc, 0xca, 0x1d, 0x5f, 0x6d, 0x40, 0x54, 0x72, 0x68, 0xa2,   /*1855*/
0x91, 0x28, 0x99, 0xfd, 0xef, 0xc0, 0x78, 0x00, 0xb3, 0x3c, 0x40, 0x4a, 0x25, 0x09, 0x1c, 0xb4,   /*1871*/
0xa7, 0x42, 0x07, 0x7c, 0xf7, 0x3b, 0x56, 0xf3, 0xec, 0x45, 0x70, 0x6c, 0x73, 0xb7, 0x3b, 0xa9,   /*1887*/
0x0a, 0x54, 0x6f, 0xdf, 0xd2, 0xdf, 0xd1, 0x7d, 0xe8, 0x94, 0xab, 0xd2, 0x4f, 0xc7, 0x3f, 0xff,   /*1903*/
0xe7, 0x94, 0x81, 0x54, 0xe0, 0x47, 0x7a, 0x7f, 0x1c, 0x3d, 0x02, 0x1c, 0x58, 0xf1, 0x87, 0x8c,   /*1919*/
0x38, 0x7c, 0x44, 0x72, 0x6d, 0x45, 0xe4, 0xda, 0x08, 0x12, 0x52, 0x24, 0x01, 0x80, 0xf2, 0x21,   /*1935*/
0xd9, 0xf1, 0xf4, 0xec, 0x48, 0x46, 0x90, 0xf4, 0xfd, 0xc0, 0x54, 0x0c, 0x27, 0xcb, 0x10, 0x1d,   /*1951*/
0xc0, 0x66, 0xfb, 0xec, 0x72, 0x94, 0x5e, 0x78, 0x7d, 0x2f, 0x7d, 0xde, 0xa1, 0x3d, 0x29, 0xbc,   /*1967*/
0xe0, 0x0a, 0x89, 0xdd, 0x2d, 0xe1, 0x43, 0x86, 0x04, 0xc6, 0x3c, 0xa8, 0xdf, 0x7c, 0xd6, 0x85,   /*1983*/
0x33, 0xa8, 0xea, 0xce, 0xd3, 0xdb, 0x1c, 0x6a, 0xc2, 0x47, 0x9b, 0xb7, 0x93, 0x9b, 0x5f, 0xa2,   /*1999*/
0xf8, 0x73, 0xb6, 0xd5, 0x3a, 0xee, 0x37, 0x3e, 0xe7, 0x96, 0x14, 0xdf, 0x6d, 0xb6, 0x9a, 0x57,   /*2015*/
0x7e, 0xa7, 0xcf, 0x6d, 0x87, 0xff, 0x28, 0x87, 0xf3, 0x5f, 0xf4, 0xcf, 0xe9, 0x24, 0xc6, 0x96,   /*2031*/
0x75, 0x56, 0x93, 0x15, 0x96, 0x08, 0x20, 0x12, 0x4a, 0x49, 0x5d, 0xf8, 0x14, 0x10, 0x88, 0x1c,   /*2047*/
0x05, 0xbc, 0x40, 0xd8, 0x28, 0x25, 0x0b, 0x7b, 0x09, 0x04, 0xc4, 0x7d, 0x07, 0xc0, 0xe3, 0xce,   /*2063*/
0x06, 0x14, 0x1a, 0x2a, 0xcb, 0xad, 0x11, 0x5a, 0x9f, 0x37, 0x44, 0xe3, 0x8e, 0x81, 0x9c, 0x92,   /*2079*/
0x80, 0x11, 0xe4, 0xd8, 0xa7, 0x19, 0x1d, 0xaf, 0xfa, 0xce, 0xa6, 0x28, 0xb5, 0x22, 0x84, 0xd2,   /*2095*/
0x7e, 0x53, 0xde, 0x97, 0xa2, 0xaa, 0x99, 0xf1, 0xad, 0xd6, 0x53, 0xb9, 0x11, 0x45, 0xa4, 0x91,   /*2111*/
0x44, 0x9c, 0x77, 0xa1, 0x67, 0x53, 0x63, 0x5a, 0x10, 0xa7, 0x69, 0x7a, 0xaf, 0x8a, 0xfe, 0x62,   /*2127*/
0xb2, 0x9c, 0xff, 0xfb, 0x90, 0x60, 0xc1, 0x00, 0x03, 0x5b, 0x48, 0xde, 0xe9, 0xec, 0x2b, 0x68,   /*2143*/
0x4a, 0x06, 0x7b, 0xed, 0x25, 0x02, 0x5b, 0x0d, 0xb5, 0x21, 0x79, 0xa6, 0x2d, 0x6b, 0xa1, 0x1b,   /*2159*/
0x87, 0x2e, 0xf4, 0x93, 0x94, 0xd8, 0xe9, 0x2a, 0xa5, 0xfc, 0x58, 0x20, 0x1a, 0xbd, 0x96, 0xc2,   /*2175*/
0xa1, 0x3b, 0xaf, 0x87, 0x18, 0x22, 0x5c, 0xfa, 0x99, 0x20, 0xaa, 0xde, 0xe9, 0xb6, 0x6f, 0xb9,   /*2191*/
0x82, 0x53, 0x7e, 0xb6, 0x3e, 0xdf, 0x74, 0xfb, 0xa7, 0xdb, 0x61, 0x4f, 0x6d, 0x30, 0xf2, 0xc3,   /*2207*/
0x3a, 0x4e, 0x58, 0xee, 0xcd, 0x37, 0xba, 0x39, 0xdd, 0xbe, 0x1c, 0xc8, 0x88, 0xb8, 0x5b, 0xbb,   /*2223*/
0x7a, 0x28, 0x57, 0xc4, 0x1e, 0x3e, 0xf8, 0x9d, 0x25, 0xf9, 0x9b, 0xcd, 0xbf, 0xdb, 0x67, 0x9d,   /*2239*/
0xbb, 0x47, 0xca, 0x82, 0x54, 0xa8, 0x72, 0x8b, 0xb5, 0xca, 0x28, 0x2f, 0x08, 0xaa, 0x42, 0x44,   /*2255*/
0x65, 0x24, 0x91, 0x33, 0x78, 0x89, 0x43, 0xa2, 0x90, 0xc8, 0x4c, 0xd8, 0xa6, 0x44, 0x71, 0x14,   /*2271*/
0x88, 0x5b, 0x62, 0x86, 0x9e, 0xa6, 0x67, 0xb8, 0x48, 0xb6, 0x3f, 0x6d, 0xea, 0xaf, 0x42, 0xbb,   /*2287*/
0x1d, 0xa8, 0xee, 0xea, 0xeb, 0xa6, 0xcd, 0xef, 0xb9, 0x8c, 0x44, 0x3b, 0x6a, 0xaa, 0x57, 0x14,   /*2303*/
0x0d, 0x69, 0xc8, 0x61, 0x2c, 0x48, 0x19, 0xa4, 0x05, 0x28, 0x4f, 0xe2, 0x14, 0x8a, 0xa5, 0xfb,   /*2319*/
0x01, 0xe2, 0x8b, 0x42, 0xd6, 0xef, 0x4c, 0x02, 0x14, 0x20, 0x7c, 0x5a, 0x3e, 0xa5, 0xd0, 0xb3,   /*2335*/
0x28, 0x68, 0xa2, 0x09, 0x29, 0x26, 0xdc, 0xc1, 0x81, 0x30, 0x74, 0x35, 0x68, 0x54, 0x42, 0x46,   /*2351*/
0x56, 0x4a, 0x63, 0x09, 0x41, 0xe4, 0x17, 0x8e, 0x8c, 0x41, 0x9a, 0xf9, 0x52, 0x01, 0xd8, 0xcc,   /*2367*/
0xac, 0xb2, 0x27, 0x5e, 0x46, 0xc3, 0x4a, 0x9e, 0x54, 0x25, 0x13, 0x59, 0xa8, 0xc9, 0x41, 0x41,   /*2383*/
0xf6, 0x36, 0x44, 0x10, 0xa2, 0xef, 0xb3, 0x34, 0xf5, 0x70, 0x5c, 0x2b, 0xd8, 0xde, 0xfd, 0x4e,   /*2399*/
0x61, 0x95, 0x22, 0x28, 0x88, 0x1c, 0x97, 0xdc, 0x0a, 0x5a, 0xfd, 0x14, 0x43, 0x75, 0xb6, 0x4c,   /*2415*/
0x45, 0x99, 0x47, 0xac, 0x8f, 0x8c, 0x97, 0x1e, 0x88, 0x55, 0x61, 0x80, 0x4f, 0xb4, 0xd3, 0x3b,   /*2431*/
0xca, 0x5f, 0xfe, 0x7f, 0xd7, 0xf3, 0x6f, 0x76, 0x79, 0xab, 0xda, 0xe7, 0x33, 0x62, 0x84, 0x2b,   /*2447*/
0x88, 0xa0, 0x51, 0x24, 0x15, 0x7b, 0x40, 0x64, 0x51, 0xf8, 0x04, 0x1f, 0xf6, 0x47, 0x22, 0x88,   /*2463*/
0x7e, 0x1c, 0xa1, 0x80, 0xc3, 0x75, 0x2c, 0x34, 0x9a, 0xa7, 0x9a, 0xff, 0x48, 0x8b, 0x6f, 0x8a,   /*2479*/
0x90, 0x1b, 0x02, 0x72, 0x31, 0x59, 0xbe, 0xff, 0x7a, 0x48, 0xe6, 0x2e, 0xaa, 0xe9, 0x99, 0xd1,   /*2495*/
0x19, 0x98, 0xab, 0x43, 0x31, 0xdb, 0xbb, 0x3b, 0xb3, 0x23, 0x76, 0xcf, 0xb2, 0x37, 0xb8, 0xc7,   /*2511*/
0x1d, 0x0d, 0x23, 0x2b, 0xa9, 0x38, 0x26, 0xb7, 0x9c, 0x52, 0xd8, 0x97, 0xb5, 0x45, 0xc3, 0x02,   /*2527*/
0x92, 0x85, 0x5a, 0xde, 0x5f, 0xd6, 0x6c, 0xdb, 0x51, 0x45, 0x14, 0x92, 0x44, 0xaa, 0x23, 0xc4,   /*2543*/
0xfd, 0x03, 0x17, 0xff, 0xfb, 0x90, 0x60, 0xca, 0x80, 0x03, 0x67, 0x49, 0x5f, 0x69, 0xeb, 0x5b,   /*2559*/
0x68, 0x54, 0xa5, 0x8b, 0xff, 0x24, 0xe5, 0x5b, 0x0d, 0xbc, 0xe9, 0x77, 0xa6, 0x25, 0x0b, 0x49,   /*2575*/
0x62, 0x24, 0x2f, 0x74, 0x94, 0x09, 0x74, 0x78, 0x3c, 0xe1, 0x2b, 0xd8, 0x9c, 0x58, 0x97, 0x1d,   /*2591*/
0x6a, 0xdb, 0xaa, 0x15, 0x26, 0xdf, 0x5d, 0x0a, 0xc8, 0x7e, 0x3b, 0x7d, 0x57, 0xfd, 0x94, 0x16,   /*2607*/
0x77, 0x0f, 0x99, 0xdd, 0x2f, 0xb1, 0x28, 0x6b, 0x7e, 0xf9, 0x71, 0xbf, 0x94, 0xf5, 0xbb, 0x41,   /*2623*/
0x26, 0xf6, 0x59, 0x0d, 0x8b, 0x2b, 0x0f, 0x27, 0x62, 0x3e, 0x22, 0x48, 0x1c, 0x89, 0x9d, 0x32,   /*2639*/
0x13, 0x45, 0x33, 0x06, 0x7d, 0xc9, 0xc5, 0x51, 0xa4, 0x96, 0x8b, 0xc7, 0xfd, 0x9b, 0xff, 0xb8,   /*2655*/
0xea, 0xfb, 0xdb, 0x74, 0x8b, 0xda, 0x13, 0xce, 0xa1, 0xef, 0x55, 0x48, 0x6e, 0xa9, 0x69, 0xe5,   /*2671*/
0x11, 0x63, 0xeb, 0x5d, 0xc9, 0x1b, 0xa1, 0x13, 0x45, 0x12, 0x91, 0x24, 0xbb, 0xdc, 0x02, 0x81,   /*2687*/
0x01, 0xc1, 0x40, 0x25, 0x5e, 0x29, 0x93, 0x12, 0x2e, 0xed, 0x67, 0x78, 0x06, 0xff, 0x51, 0xa2,   /*2703*/
0xf7, 0xd5, 0x2e, 0xbc, 0xb6, 0x8c, 0xaa, 0x55, 0x74, 0x70, 0x8b, 0xa9, 0x98, 0x83, 0xb2, 0x12,   /*2719*/
0xba, 0x5f, 0x23, 0xcc, 0xa5, 0x43, 0x5a, 0x4a, 0x55, 0xe8, 0xb6, 0x30, 0x9c, 0x8e, 0x7a, 0xa1,   /*2735*/
0x8e, 0x6b, 0x9d, 0x9a, 0xc8, 0x54, 0x1e, 0xc6, 0x29, 0xd8, 0x4a, 0x39, 0xa7, 0x49, 0x10, 0xa5,   /*2751*/
0xea, 0xea, 0xb1, 0x6f, 0x4a, 0x58, 0x44, 0x51, 0x29, 0x2f, 0x1e, 0xe9, 0x26, 0xa1, 0x4f, 0xd4,   /*2767*/
0x9f, 0xb3, 0x20, 0x8a, 0x29, 0x24, 0x89, 0x75, 0x78, 0x88, 0x3a, 0x99, 0x19, 0x87, 0x66, 0x05,   /*2783*/
0x02, 0xeb, 0x0d, 0x2a, 0x2a, 0x08, 0xa7, 0xff, 0xa9, 0x1e, 0x7d, 0x7a, 0xd4, 0x2f, 0xff, 0x7c,   /*2799*/
0xef, 0x3f, 0x95, 0xa4, 0xe2, 0x7d, 0x52, 0xfa, 0x71, 0x83, 0x1d, 0xde, 0x02, 0x1f, 0xe6, 0x75,   /*2815*/
0x9e, 0x22, 0x94, 0x65, 0x97, 0x6e, 0xcd, 0x51, 0x32, 0x79, 0xf7, 0x9e, 0x21, 0xa0, 0xe1, 0x0e,   /*2831*/
0x5f, 0x47, 0xcb, 0x34, 0x43, 0x3e, 0xae, 0xd2, 0x0d, 0x93, 0xa6, 0xa2, 0x51, 0xe4, 0xc9, 0x8b,   /*2847*/
0x89, 0x9e, 0xfb, 0xea, 0x4c, 0xda, 0x09, 0x8f, 0x1e, 0x68, 0xfa, 0x05, 0x97, 0x0e, 0xcc, 0x0a,   /*2863*/
0x0d, 0x59, 0x3e, 0xa3, 0x9a, 0x4c, 0xc5, 0xae, 0x59, 0x8c, 0xab, 0x31, 0x19, 0x89, 0x94, 0x92,   /*2879*/
0x45, 0x3b, 0x26, 0xf7, 0xf1, 0x9b, 0x69, 0x46, 0x27, 0x89, 0x54, 0x9d, 0xa8, 0xd0, 0xb9, 0x0b,   /*2895*/
0x15, 0x3c, 0x38, 0x8f, 0x96, 0x01, 0x56, 0x5b, 0xa5, 0xbd, 0x0e, 0xce, 0xfa, 0x24, 0xb3, 0x58,   /*2911*/
0x27, 0xd3, 0xb9, 0x5f, 0x32, 0xe6, 0xe4, 0x79, 0x91, 0x55, 0x33, 0x3c, 0xde, 0x10, 0x3b, 0xf2,   /*2927*/
0xdd, 0x69, 0xf9, 0x69, 0x69, 0xe5, 0x91, 0x1e, 0x95, 0x3e, 0xe7, 0xdd, 0xca, 0x88, 0xaf, 0xaa,   /*2943*/
0x23, 0x18, 0x31, 0x66, 0x25, 0x85, 0x9b, 0xd4, 0x5b, 0xaf, 0x53, 0x94, 0x49, 0x2a, 0x78, 0xb3,   /*2959*/
0xa5, 0x59, 0xac, 0x5b, 0xff, 0xfb, 0x90, 0x60, 0xc5, 0x00, 0x03, 0x58, 0x44, 0x5e, 0xe9, 0xeb,   /*2975*/
0x32, 0xe8, 0x5a, 0xe7, 0x3b, 0xdd, 0x25, 0x05, 0x5b, 0x0d, 0x19, 0x03, 0x7b, 0xa6, 0x25, 0x0b,   /*2991*/
0xa1, 0x68, 0xa2, 0xef, 0xbc, 0xc3, 0x8d, 0x74, 0x48, 0x91, 0x49, 0x12, 0x91, 0x44, 0xbc, 0x27,   /*3007*/
0xa5, 0x09, 0x51, 0x0c, 0xce, 0x4a, 0x2b, 0x4a, 0x97, 0x55, 0xa8, 0x19, 0x27, 0x91, 0x0f, 0x8b,   /*3023*/
0xd2, 0xc6, 0x0b, 0x37, 0x65, 0x5b, 0xfb, 0x17, 0x27, 0x77, 0xb7, 0x96, 0x36, 0xdb, 0x61, 0x4d,   /*3039*/
0x7d, 0xfe, 0x6f, 0x6f, 0x3f, 0xfc, 0x8a, 0x8e, 0x6e, 0xeb, 0x22, 0xcd, 0x72, 0x7e, 0x12, 0xa6,   /*3055*/
0xcb, 0x51, 0xc2, 0xd3, 0x37, 0x65, 0x09, 0xed, 0x1a, 0xfe, 0xaf, 0x2f, 0xea, 0xd6, 0xbd, 0xbc,   /*3071*/
0xc8, 0xfa, 0xcd, 0x1f, 0xf2, 0x9e, 0xe4, 0x9b, 0x0f, 0xdd, 0x88, 0x0b, 0x5a, 0xd3, 0xa5, 0x37,   /*3087*/
0x9d, 0xc9, 0x12, 0x2e, 0x78, 0x56, 0x11, 0x4d, 0x2e, 0xb1, 0x52, 0x6b, 0x19, 0x28, 0x90, 0x51,   /*3103*/
0x24, 0x05, 0x64, 0x3d, 0x32, 0x28, 0x8e, 0xc5, 0x32, 0x49, 0xa9, 0x4a, 0xc4, 0x0b, 0x26, 0x22,   /*3119*/
0xac, 0xf6, 0x9c, 0x9a, 0x31, 0xfe, 0x27, 0x46, 0x7f, 0xf1, 0x3c, 0xff, 0xac, 0xde, 0xac, 0x75,   /*3135*/
0x45, 0x86, 0x21, 0xd0, 0x8e, 0x4d, 0x36, 0xda, 0xdf, 0xb8, 0x52, 0x82, 0x51, 0xe0, 0x8a, 0x87,   /*3151*/
0xb4, 0x3a, 0xc3, 0x42, 0xa0, 0x55, 0x86, 0x20, 0x2b, 0xc8, 0x9e, 0x7d, 0x4e, 0xf3, 0xc8, 0x99,   /*3167*/
0x5b, 0xeb, 0x5a, 0x06, 0xe2, 0xec, 0x9c, 0x74, 0x96, 0xd1, 0x82, 0x72, 0x68, 0xab, 0xa2, 0x93,   /*3183*/
0x58, 0x21, 0x52, 0x13, 0x22, 0x29, 0x34, 0x92, 0x54, 0xd0, 0x18, 0xc9, 0x64, 0xfa, 0x91, 0x14,   /*3199*/
0x3b, 0x56, 0xed, 0x77, 0xcc, 0x91, 0xb8, 0x76, 0xd3, 0x04, 0x91, 0x73, 0xbb, 0x29, 0xe2, 0xe3,   /*3215*/
0x35, 0x6d, 0x2a, 0xa5, 0xca, 0x09, 0x12, 0x25, 0xaf, 0x4d, 0x80, 0x22, 0xb7, 0x40, 0x94, 0x77,   /*3231*/
0xfe, 0x22, 0x74, 0xb9, 0x25, 0xb8, 0xda, 0x86, 0xad, 0x8a, 0x7e, 0xf3, 0x27, 0xc3, 0xe9, 0x56,   /*3247*/
0xf7, 0x73, 0x74, 0x98, 0x72, 0x71, 0x21, 0xe5, 0x9e, 0x60, 0x0e, 0xfe, 0x26, 0xf7, 0x66, 0x10,   /*3263*/
0x1c, 0xaa, 0x7b, 0x8d, 0x43, 0x73, 0x25, 0xbb, 0xad, 0x6e, 0x81, 0xc5, 0x02, 0x11, 0x57, 0xa0,   /*3279*/
0xfb, 0x2c, 0x4f, 0xf0, 0x9b, 0x85, 0x05, 0x8c, 0xff, 0xb2, 0x82, 0x48, 0x15, 0x31, 0x33, 0x12,   /*3295*/
0x24, 0xa2, 0x89, 0x52, 0x80, 0x70, 0xc0, 0x74, 0x52, 0x0a, 0x96, 0xc0, 0xb9, 0x44, 0x0a, 0xa8,   /*3311*/
0x7e, 0xc7, 0xad, 0x92, 0x60, 0x05, 0x06, 0x2a, 0xb8, 0x50, 0x48, 0xe5, 0x8b, 0x89, 0x64, 0xfe,   /*3327*/
0x62, 0xee, 0x9a, 0x2d, 0xd1, 0x39, 0xab, 0x43, 0xc9, 0x17, 0xbb, 0x65, 0x3a, 0x67, 0xce, 0x65,   /*3343*/
0x5d, 0x0f, 0x09, 0x6d, 0xce, 0xb3, 0xb0, 0x1a, 0x56, 0x54, 0xb1, 0x41, 0x9c, 0x43, 0x87, 0x51,   /*3359*/
0x05, 0x13, 0x5c, 0xf4, 0x3b, 0xae, 0xce, 0x2c, 0xc2, 0xa8, 0x65, 0xe1, 0xa0, 0x15, 0x69, 0x72,   /*3375*/
0x95, 0x75, 0x57, 0x5f, 0x10, 0xff, 0xfb, 0x90, 0x60, 0xbf, 0x00, 0x03, 0x1b, 0x40, 0x5e, 0xe9,   /*3391*/
0x8a, 0x32, 0xe8, 0x55, 0x24, 0x7b, 0xcd, 0x31, 0x23, 0x4b, 0x0d, 0x61, 0x07, 0x79, 0xe7, 0x9c,   /*3407*/
0xcb, 0xa1, 0x82, 0x21, 0x2e, 0xfc, 0x94, 0x0d, 0x74, 0xb5, 0x41, 0x11, 0xaf, 0xff, 0xe9, 0x4e,   /*3423*/
0x12, 0x88, 0x24, 0x94, 0x9b, 0x71, 0xbe, 0x4a, 0x85, 0x25, 0x0e, 0xcb, 0x2a, 0x39, 0xa9, 0x1c,   /*3439*/
0xbb, 0xc3, 0x8e, 0x1b, 0xce, 0xd8, 0xb5, 0xed, 0xb4, 0x7c, 0x4f, 0xf4, 0xe9, 0x6f, 0xc6, 0xf9,   /*3455*/
0xfb, 0xe7, 0x44, 0xa1, 0x3b, 0xad, 0xe5, 0xa6, 0xcf, 0x78, 0x29, 0x01, 0x56, 0xa7, 0xb6, 0xa2,   /*3471*/
0xc4, 0x0c, 0x74, 0x21, 0x36, 0xd9, 0x4a, 0x45, 0x0b, 0xb2, 0xc9, 0xb4, 0x4a, 0xe7, 0x8f, 0xc6,   /*3487*/
0x10, 0x1b, 0x76, 0x16, 0x33, 0x51, 0xa3, 0xd2, 0xba, 0x51, 0xd4, 0x40, 0x9e, 0x25, 0xe9, 0x86,   /*3503*/
0x9a, 0x6d, 0x40, 0xb5, 0xb7, 0x46, 0xd7, 0xff, 0x1d, 0x5b, 0x73, 0x1f, 0xc7, 0xf8, 0xfb, 0x6e,   /*3519*/
0xff, 0xea, 0x53, 0x50, 0x4e, 0xc1, 0x1f, 0x4d, 0x5c, 0x5d, 0x9c, 0xb6, 0xa2, 0x52, 0x28, 0x97,   /*3535*/
0x54, 0xc0, 0x28, 0x0c, 0x54, 0x03, 0x3a, 0xc8, 0x1c, 0x40, 0x3a, 0x5b, 0xde, 0x07, 0x27, 0xe3,   /*3551*/
0x32, 0xfb, 0xad, 0x51, 0x53, 0x6d, 0x94, 0x4b, 0x1f, 0x26, 0x76, 0x18, 0x36, 0x4d, 0xe0, 0xf5,   /*3567*/
0x0d, 0x61, 0x51, 0x01, 0xf9, 0xd2, 0xa9, 0x3e, 0x28, 0x07, 0x1c, 0x18, 0x05, 0xc3, 0x81, 0x91,   /*3583*/
0x19, 0x80, 0x15, 0x02, 0xa0, 0x1a, 0x58, 0x8d, 0xa5, 0x6b, 0x84, 0xdf, 0x73, 0xc1, 0xe2, 0x9b,   /*3599*/
0x95, 0x5a, 0xb9, 0x61, 0x64, 0x58, 0xc8, 0xca, 0xf5, 0x2f, 0x5a, 0x98, 0xaa, 0x91, 0x24, 0x92,   /*3615*/
0x49, 0x20, 0xd2, 0x46, 0x29, 0x6c, 0x08, 0x34, 0x8a, 0x75, 0x25, 0x87, 0x09, 0x9c, 0x6b, 0x46,   /*3631*/
0x1c, 0x62, 0x20, 0x48, 0x39, 0xaf, 0x55, 0x5b, 0xfe, 0xf6, 0x65, 0x15, 0x00, 0xcd, 0x4b, 0x7b,   /*3647*/
0x34, 0x6e, 0xcf, 0x9d, 0x6e, 0xf5, 0xee, 0x67, 0xf9, 0x66, 0x93, 0x63, 0x1e, 0x58, 0x36, 0xf7,   /*3663*/
0x1f, 0xfc, 0x13, 0x5a, 0x6b, 0x64, 0x0c, 0x51, 0x9a, 0x6f, 0xd4, 0x27, 0x72, 0x63, 0x05, 0xc1,   /*3679*/
0x94, 0xce, 0x49, 0x0d, 0x2d, 0x93, 0x7b, 0xf9, 0x7f, 0xf6, 0xfc, 0xb4, 0xb8, 0x1b, 0x8a, 0x6f,   /*3695*/
0x2e, 0x18, 0x11, 0xa6, 0x5e, 0x8f, 0xa4, 0xa3, 0x5a, 0x66, 0xdd, 0x74, 0x7d, 0x41, 0x5b, 0x9d,   /*3711*/
0x69, 0x24, 0x52, 0x24, 0x95, 0xa6, 0xa5, 0x81, 0xdd, 0xc1, 0xa8, 0x24, 0x32, 0x29, 0x18, 0xab,   /*3727*/
0xd1, 0x11, 0xe0, 0x38, 0x83, 0xaa, 0x08, 0x09, 0x7a, 0x08, 0x9d, 0x74, 0x75, 0xb7, 0x91, 0x79,   /*3743*/
0x0e, 0xd2, 0x21, 0x9e, 0x51, 0xca, 0xca, 0x99, 0x69, 0xa2, 0x5d, 0x9d, 0x5a, 0x33, 0xef, 0xce,   /*3759*/
0xee, 0xfa, 0x52, 0x0f, 0x62, 0xba, 0x5a, 0x0d, 0x09, 0xcc, 0xd5, 0x30, 0xbc, 0xfb, 0x3c, 0x8b,   /*3775*/
0x98, 0xae, 0x70, 0xf2, 0x53, 0xfa, 0xe9, 0x29, 0x79, 0x87, 0xb7, 0x61, 0x9d, 0xaa, 0x47, 0x22,   /*3791*/
0x11, 0x24, 0x92, 0x91, 0x44, 0xaa, 0xff, 0xfb, 0x90, 0x60, 0xbb, 0x80, 0x03, 0x56, 0x4a, 0x5d,   /*3807*/
0x69, 0xe6, 0x43, 0x60, 0x50, 0xe2, 0xeb, 0xca, 0x1c, 0xc2, 0x49, 0x0c, 0x59, 0x01, 0x75, 0xa7,   /*3823*/
0x8c, 0xcb, 0xa1, 0x42, 0x9d, 0x2f, 0x34, 0xc2, 0x89, 0x6c, 0x78, 0x94, 0x89, 0xa7, 0x03, 0x25,   /*3839*/
0x3a, 0x7f, 0x4c, 0xba, 0xb7, 0xe5, 0x41, 0xc3, 0x8d, 0x65, 0x76, 0x30, 0xfd, 0x12, 0x9d, 0x1d,   /*3855*/
0xe7, 0x6e, 0xe5, 0x46, 0xd9, 0xfb, 0xd3, 0x12, 0x7f, 0x90, 0x1f, 0x8b, 0xaa, 0x40, 0x56, 0xe3,   /*3871*/
0x35, 0x23, 0x67, 0xe8, 0x6b, 0xa5, 0x4b, 0x71, 0x64, 0x5e, 0xe2, 0x81, 0x53, 0x0d, 0x12, 0x09,   /*3887*/
0x01, 0x86, 0x4b, 0x05, 0x54, 0x48, 0xdb, 0x2c, 0x76, 0xa8, 0x25, 0x81, 0x69, 0x99, 0x43, 0x2c,   /*3903*/
0x88, 0x61, 0x83, 0xd6, 0x7b, 0x43, 0x58, 0xf7, 0x15, 0x58, 0x60, 0xb0, 0x86, 0x3c, 0xc0, 0x9c,   /*3919*/
0x0a, 0xdb, 0xb5, 0xd5, 0xa2, 0xd8, 0xb9, 0xe4, 0x5b, 0xb3, 0x53, 0x78, 0x88, 0x92, 0x6d, 0x24,   /*3935*/
0x92, 0x49, 0xed, 0x0e, 0x89, 0x23, 0x90, 0x93, 0xff, 0xf3, 0xa9, 0x5d, 0x23, 0x30, 0x8d, 0x14,   /*3951*/
0x5c, 0x34, 0xa6, 0x47, 0xe9, 0x6a, 0xde, 0x8a, 0x7b, 0x32, 0xee, 0xaf, 0xce, 0xfa, 0x09, 0xbd,   /*3967*/
0xb9, 0x8f, 0x06, 0xab, 0x69, 0x97, 0x4e, 0xcc, 0x52, 0xa2, 0x12, 0x48, 0xa9, 0x6e, 0x76, 0x64,   /*3983*/
0x20, 0x72, 0xcd, 0x28, 0x64, 0x88, 0x89, 0x6b, 0x28, 0x12, 0x9a, 0x86, 0xc9, 0x39, 0x8d, 0x53,   /*3999*/
0x4a, 0x87, 0xc9, 0xff, 0xe8, 0x6a, 0x39, 0xcb, 0xa5, 0x39, 0xea, 0x39, 0x72, 0xfe, 0x29, 0x34,   /*4015*/
0xd2, 0x54, 0x81, 0x0e, 0x33, 0xc5, 0x9f, 0x3d, 0x75, 0xb5, 0x3e, 0x3f, 0xbc, 0x67, 0x03, 0xd1,   /*4031*/
0x26, 0xa5, 0xad, 0x2d, 0xe2, 0x6a, 0xe2, 0x1f, 0xeb, 0xbe, 0xcb, 0x02, 0x33, 0x4d, 0x49, 0x36,   /*4047*/
0x3c, 0xd5, 0x96, 0x1a, 0x3d, 0x69, 0xae, 0xe8, 0x69, 0xd5, 0x29, 0x11, 0x42, 0x49, 0x8b, 0xdd,   /*4063*/
0x3d, 0x87, 0xc4, 0x30, 0x50, 0x15, 0x83, 0x51, 0xe5, 0x30, 0x94, 0x56, 0xee, 0xcc, 0x15, 0x6a,   /*4079*/
0x24, 0x94, 0x2e, 0x0d, 0xb2, 0x0d, 0xa5, 0x81, 0xc6, 0x0b, 0x19, 0x35, 0x7b, 0x24, 0x3e, 0xbe,   /*4095*/
0xd2, 0x44, 0x6a, 0xcf, 0x22, 0x13, 0xd5, 0x45, 0x03, 0x36, 0x06, 0x1d, 0x5b, 0x1c, 0x8e, 0xc9,   /*4111*/
0x9b, 0x20, 0x11, 0x80, 0x4b, 0xc4, 0x46, 0x01, 0xc2, 0xc0, 0x24, 0x04, 0x88, 0x67, 0x9d, 0x80,   /*4127*/
0xd8, 0x84, 0x57, 0x09, 0x80, 0x82, 0x54, 0x8c, 0x0a, 0x00, 0x05, 0x41, 0x03, 0x0d, 0x18, 0x41,   /*4143*/
0x72, 0x21, 0x23, 0x02, 0x3d, 0x18, 0xb6, 0x10, 0x81, 0x91, 0x10, 0x00, 0x43, 0x09, 0x8d, 0x20,   /*4159*/
0x08, 0x00, 0x1d, 0x02, 0x80, 0x08, 0x40, 0x30, 0x01, 0x80, 0x10, 0x40, 0x00, 0x28, 0x25, 0x00,   /*4175*/
0x40, 0x05, 0x82, 0x83, 0x02, 0x10, 0x10, 0x02, 0x80, 0x30, 0x03, 0x10, 0x4d, 0x80, 0x78, 0x12,   /*4191*/
0x4e, 0x64, 0x05, 0x40, 0xa0, 0x81, 0x40, 0x22, 0xa5, 0x41, 0x09, 0x14, 0x13, 0x6d, 0x0c, 0x25,   /*4207*/
0x00, 0x01, 0x04, 0x80, 0x46, 0x0c, 0x1a, 0x8f, 0x5a, 0x80, 0x00, 0x40, 0x00, 0x00, 0x45, 0x06,   /*4223*/
0x09, 0x41, 0xc2, 0x42, 0x20, 0x40, 0x80, 0x98, 0x49, 0x20, 0x40, 0x51, 0x0c, 0x44, 0x69, 0x07,   /*4239*/
0x04, 0x01, 0x01, 0x80, 0x00, 0x10, 0xee, 0xc0, 0x80, 0x08, 0x64, 0x89, 0x00, 0x38, 0xe5, 0x38,   /*4255*/
0xd0, 0x3c, 0x00, 0x77, 0x69, 0x73, 0x00, 0x41, 0x30, 0xa0, 0x40, 0x27, 0xa0, 0x4b, 0x04, 0x20,   /*4271*/
0x58, 0x1c, 0x86, 0x04, 0x22, 0xa2, 0x18, 0x04, 0x25, 0xb2, 0xc1, 0x20, 0x32, 0x90, 0x05, 0x89,   /*4287*/
0x20, 0x21, 0x42, 0xc2, 0xa3, 0x3b, 0x4d, 0x70, 0x23, 0x90, 0x00, 0x08, 0x15, 0x45, 0x80, 0x00,   /*4303*/
0x2e, 0x40, 0x88, 0x2a, 0x01, 0x31, 0x59, 0x81, 0x41, 0x3c, 0x58, 0x50, 0xc9, 0x04, 0x30, 0x43,   /*4319*/
0xf9, 0x1e, 0x3f, 0x43, 0x4c, 0x77, 0x42, 0x82, 0x45, 0x85, 0x58, 0xa4, 0x62, 0x84, 0xa9, 0x40,   /*4335*/
0x09, 0x61, 0x65, 0xbb, 0x6a, 0x53, 0x50, 0xc2, 0x04, 0x00, 0x09, 0x20, 0x30, 0x85, 0x10, 0xb8,   /*4351*/
0xa2, 0x40, 0x12, 0x09, 0xa4, 0xc0, 0x12, 0x80, 0x97, 0x80, 0x19, 0x9d, 0x54, 0x88, 0xc2, 0x13,   /*4367*/
0x89, 0x09, 0xe0, 0x83, 0xca, 0x2b, 0x22, 0xa0, 0x31, 0xa6, 0x3a, 0x2f, 0x12, 0x15, 0x05, 0x00,   /*4383*/
0x00, 0xa1, 0x04, 0x20, 0x88, 0x8e, 0x98, 0x09, 0x02, 0x09, 0x20, 0x8a, 0x21, 0x2c, 0x43, 0x38,   /*4399*/
0x18, 0xa0, 0x98, 0x10, 0xa2, 0x0d, 0x88, 0x01, 0x10, 0x5c, 0x00, 0xa0, 0x00, 0x48, 0x62, 0xcc,   /*4415*/
0x31, 0x20, 0x42, 0x91, 0x0a, 0x95, 0x10, 0x4d, 0x00, 0x42, 0x44, 0x0a, 0x0c, 0x52, 0x20, 0x56,   /*4431*/
0x14, 0x21, 0x03, 0x18, 0x08, 0x84, 0x12, 0xc3, 0x14, 0x81, 0x03, 0x2a, 0x12, 0x3d, 0x20, 0x09,   /*4447*/
0x2b, 0x21, 0x3d, 0x24, 0x14, 0x04, 0x00, 0x49, 0xa0, 0x13, 0x08, 0x53, 0x70, 0x20, 0x0c, 0x84,   /*4463*/
0x21, 0x12, 0x0c, 0x20, 0x18, 0xb1, 0xc2, 0xa6, 0x41, 0x8a, 0x50, 0x23, 0x00, 0x41, 0x11, 0xa2,   /*4479*/
0x00, 0x10, 0x1b, 0x14, 0x00, 0x45, 0x00, 0x02, 0x13, 0x14, 0x49, 0x10, 0x05, 0xf0, 0x7e, 0x24,   /*4495*/
0x2b, 0x42, 0xd0, 0x09, 0x58, 0x24, 0x21, 0x36, 0x93, 0x0d, 0x0d, 0x22, 0x02, 0x33, 0x25, 0x07,   /*4511*/
0x80, 0x95, 0x08, 0xc1, 0x03, 0x20, 0x62, 0x88, 0x0c, 0xcc, 0x02, 0x86, 0x10, 0x90, 0xc2, 0x05,   /*4527*/
0x20, 0x08, 0x8b, 0x82, 0x20, 0x08, 0xa0, 0x44, 0x48, 0x08, 0x80, 0x50, 0x02, 0x4c, 0x18, 0x10,   /*4543*/
0x11, 0x54, 0x86, 0x14, 0x8c, 0xfa, 0x1d, 0x20, 0x78, 0x57, 0x52, 0x81, 0x14, 0x51, 0x14, 0xa0,   /*4559*/
0x95, 0x01, 0xa4, 0x0a, 0x00, 0x20, 0x30, 0x04, 0xc9, 0xc2, 0xbb, 0x24, 0x22, 0x06, 0x0a, 0x20,   /*4575*/
0x00, 0x28, 0x20, 0x1a, 0xb0, 0x00, 0xa8, 0x20, 0x62, 0x02, 0xc8, 0x26, 0xa0, 0x43, 0x31, 0x41,   /*4591*/
0x62, 0x10, 0x30, 0x96, 0x19, 0x21, 0xc1, 0x99, 0x20, 0x0b, 0x22, 0x00, 0x80, 0x04, 0x40, 0x20,   /*4607*/
0x11, 0x09, 0x02, 0x10, 0x44, 0x82, 0x4c, 0x0a, 0x24, 0x92, 0xa3, 0x21, 0x30, 0x21, 0x98, 0xd8,   /*4623*/
0x68, 0x40, 0x40, 0xd0, 0xc1, 0x94, 0x02, 0xa2, 0x73, 0x1b, 0x80, 0x00, 0x44, 0x00, 0x01, 0x10,   /*4639*/
0x40, 0x44, 0xe1, 0x88, 0x02, 0xc0, 0x41, 0x04, 0x21, 0x01, 0x10, 0x02, 0x1a, 0x00, 0x9c, 0x03,   /*4655*/
0x35, 0xa5, 0x81, 0x2b, 0x20, 0x48, 0x14, 0x6e, 0x70, 0x02, 0x84, 0x40, 0x52, 0x05, 0x21, 0x6a,   /*4671*/
0x34, 0x5a, 0x91, 0x00, 0x02, 0x53, 0x84, 0x06, 0x04, 0x06, 0x14, 0x12, 0x01, 0x40, 0x02, 0x20,   /*4687*/
0xc8, 0x0f, 0xb2, 0x41, 0x24, 0x85, 0xc0, 0x00, 0x18, 0x41, 0x08, 0x02, 0x01, 0x00, 0x0d, 0xc9,   /*4703*/
0x02, 0x82, 0x48, 0x80, 0x22, 0xa8, 0x80, 0x92, 0x0b, 0x04, 0xae, 0x01, 0x40, 0x00, 0x84, 0x4a,   /*4719*/
0x45, 0x62, 0x52, 0x00, 0x20, 0x8b, 0x22, 0xa1, 0x67, 0xa4, 0x84, 0x01, 0x70, 0x0b, 0x46, 0x81,   /*4735*/
0x59, 0x04, 0x89, 0x27, 0x0c, 0x83, 0x13, 0x00, 0x28, 0xc0, 0x03, 0x6c, 0x10, 0x52, 0x20, 0x13,   /*4751*/
0x22, 0x00, 0x00, 0x00, 0x0c, 0x1a, 0x10, 0x7c, 0x30, 0xa8, 0x30, 0x26, 0x18, 0x20, 0x25, 0x04,   /*4767*/
0x9c, 0xe5, 0x38, 0xc6, 0x3d, 0x98, 0x43, 0x64, 0xa0, 0x16, 0x41, 0x42, 0x95, 0x46, 0x10, 0x72,   /*4783*/
0xaa, 0x21, 0x39, 0x24, 0xf2, 0xb3, 0x2a, 0x06, 0x59, 0x52, 0x35, 0x21, 0x00, 0x4a, 0xb0, 0x22,   /*4799*/
0x0a, 0x52, 0x09, 0x50, 0x2d, 0x02, 0xb8, 0x21, 0x50, 0x0a, 0x92, 0x8c, 0xa1, 0x72, 0x80, 0x64,   /*4815*/
0x48, 0xca, 0x13, 0x16, 0x49, 0x82, 0xa3, 0x16, 0x20, 0x67, 0x40, 0x1a, 0xe0, 0x90, 0x82, 0x93,   /*4831*/
0x6c, 0x20, 0x44, 0x09, 0xc0, 0x21, 0x08, 0xc4, 0x81, 0x48, 0x3e, 0x10, 0x60, 0x05, 0x10, 0x80,   /*4847*/
0xa4, 0x04, 0x80, 0x84, 0x40, 0x02, 0x88, 0x09, 0x88, 0x10, 0x00, 0x08, 0x00, 0x10, 0xa0, 0x44,   /*4863*/
0x00, 0x45, 0xb0, 0x01, 0x30, 0x09, 0x03, 0xf1, 0xa1, 0x0a, 0x94, 0x18, 0x23, 0x21, 0x26, 0xb5,   /*4879*/
0x8a, 0x85, 0x03, 0xc5, 0x61, 0x10, 0x90, 0xe2, 0x87, 0x88, 0x20, 0x44, 0xb1, 0x80, 0x93, 0x0c,   /*4895*/
0x08, 0xa0, 0x00, 0x00, 0x30, 0xe0, 0x1c, 0xe4, 0x90, 0x3f, 0x90, 0x45, 0x94, 0x21, 0xd0, 0x60,   /*4911*/
0x2c, 0x89, 0x11, 0x60, 0x20, 0x02, 0x00, 0x45, 0xc1, 0x2c, 0x40, 0x28, 0x48, 0x40, 0x04, 0x05,   /*4927*/
0x62, 0x21, 0x08, 0xad, 0xb4, 0x1a, 0x49, 0x29, 0x88, 0x21, 0x42, 0x01, 0x31, 0x37, 0xc8, 0x56,   /*4943*/
0x0a, 0xcc, 0x30, 0x24, 0x09, 0x82, 0x06, 0x28, 0xa8, 0x22, 0x90, 0x88, 0x0a, 0x04, 0x3e, 0x90,   /*4959*/
0x00, 0x81, 0x90, 0x40, 0x93, 0x2a, 0x09, 0x91, 0x8d, 0x80, 0xc1, 0x39, 0xab, 0x28, 0x28, 0x96,   /*4975*/
0x71, 0x19, 0x01, 0x43, 0x84, 0x80, 0x12, 0x2a, 0x54, 0x16, 0x82, 0x48, 0x70, 0xa5, 0x04, 0x41,   /*4991*/
0x28, 0x00, 0x98, 0x24, 0x2a, 0xa8, 0x12, 0x0e, 0x08, 0x82, 0x45, 0x42, 0x09, 0x14, 0x44, 0x80,   /*5007*/
0x99, 0x41, 0x2d, 0x48, 0x02, 0x50, 0x00, 0xa0, 0x91, 0x2c, 0x40, 0xdc, 0x2c, 0x0c, 0x01, 0x44,   /*5023*/
0x42, 0xe8, 0x8c, 0x3c, 0x88, 0x10, 0x42, 0xc4, 0x02, 0xa0, 0x87, 0x33, 0x2b, 0x4a, 0x9b, 0x25,   /*5039*/
0x74, 0x15, 0x10, 0x04, 0x00, 0x00, 0x4a, 0x00, 0x70, 0xf7, 0x61, 0x90, 0x60, 0x8b, 0x80, 0x03,   /*5055*/
0x03, 0x40, 0xd8, 0x29, 0xe5, 0x42, 0xe8, 0x50, 0x28, 0x09, 0xac, 0x04, 0x82, 0x00, 0x00, 0x8d,   /*5071*/
0x02, 0x47, 0x40, 0xa0, 0x49, 0x80, 0x02, 0x8c, 0xa7, 0x04, 0xc1, 0x09, 0x24, 0xc6, 0x09, 0x50,   /*5087*/
0x91, 0x80, 0x20, 0x2b, 0xa0, 0xf9, 0x84, 0x81, 0x80, 0x60, 0xa0, 0xba, 0x86, 0x20, 0x35, 0x28,   /*5103*/
0x74, 0x00, 0x00, 0x06, 0x04, 0x8a, 0x04, 0x45, 0x4d, 0x40, 0x20, 0x81, 0x02, 0xd8, 0x89, 0xa0,   /*5119*/
0x1a, 0x47, 0x00, 0x5d, 0x84, 0xa2, 0x6a, 0x94, 0x84, 0x22, 0x22, 0xec, 0xb0, 0xa0, 0x50, 0xc8,   /*5135*/
0xe0, 0x42, 0x75, 0x02, 0x91, 0x20, 0x2b, 0xc1, 0x84, 0x04, 0x28, 0x01, 0x30, 0x02, 0x08, 0x4a,   /*5151*/
0x0d, 0x01, 0x90, 0x03, 0x01, 0x04, 0x01, 0x08, 0xc0, 0x21, 0x00, 0x08, 0x05, 0x08, 0x02, 0x44,   /*5167*/
0xc4, 0x01, 0x00, 0x04, 0x4a, 0x06, 0x24, 0x46, 0x63, 0xc0, 0xcc, 0x20, 0x60, 0x72, 0x94, 0x01,   /*5183*/
0xa2, 0x4a, 0x84, 0x52, 0x52, 0xb9, 0x24, 0x61, 0x21, 0x32, 0x00, 0x01, 0xda, 0x44, 0x1e, 0x2b,   /*5199*/
0x20, 0x50, 0x09, 0x08, 0xd2, 0x00, 0x08, 0x66, 0x1a, 0x1a, 0x44, 0x01, 0x1c, 0x93, 0x80, 0x01,   /*5215*/
0xe9, 0xb2, 0x90, 0xa2, 0x40, 0x81, 0x80, 0x0a, 0x89, 0x0c, 0x62, 0x11, 0xa8, 0x07, 0x0e, 0x46,   /*5231*/
0x80, 0x84, 0x09, 0x85, 0x1b, 0x6a, 0x36, 0xd3, 0xca, 0x12, 0x10, 0x61, 0x71, 0x2a, 0x02, 0x02,   /*5247*/
0x0b, 0x2a, 0x85, 0x42, 0xe0, 0x51, 0x43, 0xa0, 0x09, 0x15, 0x73, 0xc8, 0xc0, 0x84, 0xa0, 0xc1,   /*5263*/
0x06, 0x38, 0x20, 0x4b, 0x06, 0x45, 0x84, 0x4a, 0x06, 0x02, 0xa0, 0x08, 0x45, 0x38, 0x50, 0x69,   /*5279*/
0x70, 0x00, 0x90, 0x20, 0x46, 0xa8, 0x84, 0x80, 0xb0, 0x34, 0x08, 0x40, 0x22, 0xa6, 0x21, 0xc1,   /*5295*/
0x16, 0x00, 0x88, 0x2a, 0xc5, 0x88, 0x01, 0x0b, 0x02, 0x10, 0x80, 0x20, 0x81, 0x42, 0x84, 0x80,   /*5311*/
0x38, 0xf3, 0x25, 0x00, 0x02, 0x82, 0x48, 0x44, 0x86, 0xc1, 0x07, 0x10, 0x08, 0x20, 0x79, 0x6a,   /*5327*/
0x50, 0x87, 0x0b, 0x30, 0x51, 0x48, 0x00, 0x75, 0x63, 0x5e, 0x40, 0x03, 0x2a, 0x24, 0x10, 0x48,   /*5343*/
0xa4, 0x8a, 0x01, 0x18, 0x46, 0x27, 0x7d, 0x50, 0x50, 0x40, 0x35, 0x20, 0x48, 0x00, 0x81, 0x08,   /*5359*/
0x08, 0x10, 0x15, 0x06, 0x80, 0xc8, 0xe2, 0x80, 0x64, 0x13, 0x42, 0x94, 0x28, 0x80, 0x40, 0x99,   /*5375*/
0x00, 0x63, 0x5d, 0x86, 0x20, 0x01, 0x12, 0x09, 0x00, 0x35, 0x21, 0x11, 0x28, 0x00, 0x4d, 0x66,   /*5391*/
0x88, 0x2c, 0x58, 0x24, 0x70, 0x0d, 0x60, 0x82, 0x14, 0x00, 0xa0, 0x22, 0xd2, 0x18, 0x24, 0x82,   /*5407*/
0x01, 0x40, 0x00, 0x9d, 0x0b, 0x8c, 0x12, 0x00, 0x12, 0xc4, 0x69, 0x88, 0x20, 0x26, 0x88, 0x50,   /*5423*/
0x01, 0x84, 0xf2, 0xc8, 0x40, 0x40, 0xd6, 0x18, 0x00, 0x49, 0x05, 0x01, 0xec, 0x6b, 0x83, 0x96,   /*5439*/
0x55, 0x10, 0x38, 0x03, 0x10, 0xf4, 0xe2, 0x29, 0xe3, 0x28, 0x50, 0x15, 0x27, 0x02, 0xc0, 0xba,   /*5455*/
0x04, 0x00, 0x0c, 0x00, 0x40, 0x04, 0x14, 0x96, 0x01, 0x0c, 0xf6, 0x99, 0x80, 0x40, 0x00, 0x00,   /*5471*/
0x00, 0x00, 0x48, 0x40, 0x80, 0x80, 0x03, 0x20, 0x50, 0x04, 0x09, 0x0d, 0x24, 0x03, 0x18, 0x05,   /*5487*/
0x24, 0x27, 0x48, 0x02, 0x81, 0x08, 0x20, 0x42, 0x90, 0x0a, 0xa4, 0x85, 0x08, 0x6c, 0x10, 0x52,   /*5503*/
0x26, 0x00, 0x28, 0x40, 0x80, 0xa4, 0xce, 0x08, 0xe4, 0x56, 0x10, 0x40, 0x22, 0x32, 0x09, 0x82,   /*5519*/
0x04, 0x10, 0x89, 0xc0, 0x88, 0x58, 0x81, 0x56, 0x08, 0x11, 0x9c, 0x13, 0x2e, 0x64, 0x52, 0x06,   /*5535*/
0x20, 0x0a, 0x80, 0x08, 0x94, 0x40, 0x80, 0x84, 0xa2, 0x8d, 0x04, 0x00, 0xa0, 0x00, 0x1e, 0x40,   /*5551*/
0x04, 0x00, 0x44, 0x42, 0x21, 0x00, 0x83, 0x1a, 0x40, 0x08, 0x41, 0x01, 0x2a, 0x00, 0x41, 0xc1,   /*5567*/
0x25, 0x00, 0x41, 0x00, 0x48, 0x20, 0x02, 0x04, 0x00, 0xc4, 0x00, 0x14, 0x3a, 0x10, 0x18, 0x00,   /*5583*/
0x88, 0x00, 0x0c, 0x00, 0x04, 0x40, 0x95, 0x0d, 0x01, 0x0c, 0x0b, 0x5a, 0x29, 0x52, 0x08, 0x85,   /*5599*/
0xd7, 0xa9, 0x1b, 0x5c, 0xd4, 0x2a, 0x20, 0xb6, 0x60, 0x8d, 0x28, 0xc0, 0x08, 0x84, 0x80, 0x16,   /*5615*/
0xac, 0x11, 0x98, 0x0a, 0x68, 0xc2, 0x1a, 0xb2, 0x13, 0x68, 0xc5, 0x44, 0x9c, 0x01, 0x32, 0x84,   /*5631*/
0xee, 0x29, 0x10, 0x0b, 0x4d, 0xa1, 0xc5, 0x9c, 0x5b, 0x0e, 0x4a, 0x29, 0x18, 0x09, 0x01, 0x30,   /*5647*/
0xae, 0x02, 0x40, 0x30, 0x00, 0x19, 0x3b, 0x8f, 0x12, 0xb5, 0x5c, 0x29, 0x24, 0x9a, 0x48, 0xa4,   /*5663*/
0x43, 0xa8, 0x38, 0xf8, 0x01, 0x10, 0x44, 0x02, 0xb9, 0x62, 0xa3, 0xb7, 0x33, 0x80, 0x08, 0xa0,   /*5679*/
0x22, 0x20, 0xb0, 0x84, 0xa0, 0x6b, 0x44, 0x4d, 0x5b, 0x96, 0x31, 0x28, 0x35, 0x2b, 0x2c, 0xc4,   /*5695*/
0x83, 0x0a, 0x16, 0xb1, 0x0b, 0x53, 0x8e, 0x06, 0x61, 0x03, 0x00, 0x31, 0x1c, 0x8a, 0x80, 0x22,   /*5711*/
0x34, 0xfb, 0x9a, 0x6f, 0x66, 0x60, 0x37, 0xb9, 0x65, 0xa0, 0x91, 0x4f, 0xb8, 0xaa, 0x8f, 0xc0,   /*5727*/
0x2b, 0x4b, 0xac, 0x6c, 0xd5, 0x7d, 0x91, 0xc9, 0xcc, 0x47, 0x54, 0xe9, 0x42, 0xc2, 0x00, 0x80,   /*5743*/
0x08, 0x2f, 0xb9, 0x8f, 0x88, 0x45, 0x63, 0x0d, 0x60, 0x69, 0x88, 0x62, 0x24, 0x12, 0x88, 0x4d,   /*5759*/
0x6f, 0x94, 0x41, 0x9b, 0x57, 0xce, 0x26, 0x23, 0x0b, 0x60, 0xa2, 0x92, 0x20, 0xa3, 0x51, 0x42,   /*5775*/
0x72, 0x41, 0x00, 0x02, 0x38, 0x28, 0x00, 0x84, 0x50, 0x44, 0x96, 0x0a, 0x01, 0x04, 0x08, 0x40,   /*5791*/
0xd2, 0x5e, 0x80, 0x2e, 0x21, 0x21, 0x29, 0x08, 0x02, 0x61, 0xc5, 0x48, 0xa9, 0x10, 0xa1, 0x0c,   /*5807*/
0x58, 0x9c, 0x34, 0xb7, 0xf9, 0x45, 0x40, 0xad, 0x2c, 0x22, 0xd1, 0x45, 0xa9, 0x4d, 0x14, 0x72,   /*5823*/
0xb0, 0x90, 0x06, 0x4e, 0xa9, 0x13, 0x6c, 0x1a, 0x24, 0xa9, 0x0d, 0x1f, 0x4d, 0x21, 0x6b, 0x0a,   /*5839*/
0x1d, 0xe6, 0x08, 0x80, 0xc2, 0x23, 0x3b, 0x02, 0x01, 0x09, 0x20, 0x84, 0x8a, 0x04, 0x03, 0x05,   /*5855*/
0x02, 0xaa, 0xa0, 0x80, 0x88, 0x03, 0x20, 0x1a, 0x91, 0x40, 0x00, 0x0c, 0x84, 0x0f, 0x03, 0x80,   /*5871*/
0x80, 0x08, 0x11, 0x08, 0xd0, 0x40, 0x8a, 0x11, 0x29, 0x07, 0x80, 0x27, 0x3b, 0x00, 0x20, 0x91,   /*5887*/
0x00, 0x02, 0x00, 0x00, 0x18, 0x41, 0xe9, 0x02, 0x98, 0x51, 0xc7, 0x2b, 0x39, 0x31, 0xa5, 0x5b,   /*5903*/
0x0d, 0x0c, 0x0d, 0x3a, 0x87, 0xb8, 0x0b, 0xa1, 0x46, 0x18, 0xe7, 0x00, 0x46, 0x8c, 0x2c, 0x97,   /*5919*/
0x28, 0x98, 0x15, 0x46, 0x36, 0x67, 0x0a, 0xc3, 0x5e, 0xcb, 0x12, 0x6c, 0x36, 0xa0, 0x45, 0x19,   /*5935*/
0xa5, 0x2c, 0x49, 0x25, 0x82, 0x41, 0x82, 0xaa, 0xd3, 0xd4, 0x43, 0xf3, 0xe1, 0x08, 0x04, 0x20,   /*5951*/
0x00, 0x4a, 0x83, 0x02, 0x24, 0x1d, 0x19, 0x48, 0x8a, 0x40, 0x02, 0x80, 0xa0, 0x17, 0x02, 0x09,   /*5967*/
0x81, 0x0d, 0x91, 0x06, 0x08, 0x25, 0x62, 0x8d, 0x03, 0x80, 0x94, 0x48, 0x19, 0x29, 0x75, 0xc0,   /*5983*/
0x21, 0x48, 0x44, 0x34, 0x40, 0x28, 0x8b, 0x00, 0xa4, 0x20, 0x84, 0x00, 0x48, 0x02, 0x95, 0x98,   /*5999*/
0x22, 0x08, 0x30, 0x72, 0x00, 0x04, 0x0a, 0x86, 0x40, 0xf0, 0xee, 0x52, 0x12, 0x80, 0xe8, 0x44,   /*6015*/
0xc9, 0x28, 0xef, 0x74, 0x42, 0xe8, 0xca, 0x25, 0x02, 0x31, 0x25, 0x0e, 0x82, 0x11, 0xc4, 0x51,   /*6031*/
0x45, 0x69, 0x01, 0x84, 0x16, 0x48, 0xda, 0xdd, 0xea, 0x46, 0x41, 0x28, 0xa3, 0x42, 0x48, 0x62,   /*6047*/
0x48, 0xac, 0xc1, 0x8d, 0x54, 0xa7, 0x0b, 0x46, 0x12, 0xd1, 0x02, 0x01, 0x22, 0x9b, 0x45, 0xb3,   /*6063*/
0x24, 0x10, 0x48, 0x0d, 0x00, 0x00, 0x18, 0x41, 0x00, 0x13, 0x90, 0x41, 0x08, 0x60, 0x00, 0x88,   /*6079*/
0x9b, 0x08, 0xb0, 0xc2, 0x70, 0x00, 0x40, 0x86, 0xb4, 0x40, 0x84, 0x36, 0xc6, 0x96, 0x75, 0xd2,   /*6095*/
0xec, 0xcb, 0x19, 0x32, 0x06, 0x80, 0x14, 0x01, 0x43, 0x50, 0x82, 0x16, 0xb4, 0x12, 0xd6, 0x81,   /*6111*/
0xb8, 0x20, 0x01, 0x1a, 0xc2, 0x80, 0x01, 0xd5, 0x44, 0x01, 0x08, 0x73, 0xe5, 0x00, 0x40, 0x6b,   /*6127*/
0x4e, 0x40, 0x23, 0xe5, 0x61, 0x06, 0x25, 0xd7, 0x82, 0xb2, 0x80, 0x92, 0x08, 0x06, 0x00, 0x4e,   /*6143*/
0x94, 0x06, 0x84, 0x40, 0x43, 0x89, 0xc6, 0x3a, 0x0c, 0x08, 0x24, 0x90, 0x8a, 0x02, 0x89, 0xc5,   /*6159*/
0x43, 0x24, 0x80, 0x87, 0xff, 0xd1, 0xc0, 0x34, 0x48, 0x84, 0x80, 0xe1, 0x80, 0x14, 0xc1, 0x10,   /*6175*/
0xc4, 0x57, 0x88, 0xc2, 0xf8, 0x22, 0xa2, 0x1e, 0x11, 0x49, 0x20, 0x53, 0xaa, 0x02, 0x02, 0xa3,   /*6191*/
0x3c, 0x0c, 0x04, 0x5d, 0xa7, 0x10, 0x82, 0x18, 0x54, 0x40, 0x08, 0x14, 0x4e, 0x00, 0x54, 0x5d,   /*6207*/
0x6a, 0x00, 0x8b, 0x07, 0xc3, 0x01, 0x21, 0x90, 0x87, 0x34, 0x71, 0x43, 0x52, 0x00, 0x13, 0x6d,   /*6223*/
0x91, 0x11, 0x42, 0x6d, 0xb8, 0x82, 0x92, 0x46, 0x56, 0x01, 0x23, 0x43, 0x22, 0x04, 0x63, 0x2d,   /*6239*/
0x88, 0x04, 0x84, 0x5b, 0x2d, 0x1a, 0x04, 0xc9, 0x91, 0x84, 0x82, 0xe3, 0xd3, 0x1d, 0x8c, 0x92,   /*6255*/
0x4c, 0x8c, 0x2b, 0xf6, 0x32, 0x18, 0x40, 0x49, 0x72, 0x40, 0x24, 0xd0, 0x04, 0x00, 0x11, 0x2d,   /*6271*/
0x86, 0xa4, 0x81, 0x30, 0xe0, 0x08, 0x29, 0x18, 0x1a, 0x8b, 0x90, 0x0a, 0x66, 0x12, 0x95, 0x09,   /*6287*/
0x98, 0x24, 0x88, 0x21, 0xc0, 0x38, 0x30, 0x73, 0x50, 0x7c, 0xb5, 0xa3, 0xfb, 0xfb, 0x90, 0x40,   /*6303*/
0xc0, 0x00, 0x02, 0x59, 0x40, 0x45, 0xd2, 0x10, 0x50, 0xe8, 0x50, 0xcb, 0x0b, 0x49, 0x3c, 0x21,   /*6319*/
0x2d, 0x0d, 0x01, 0x03, 0x18, 0x88, 0x04, 0x49, 0xa1, 0x46, 0x0d, 0x27, 0x28, 0xd4, 0x15, 0x34,   /*6335*/
0xd4, 0x7c, 0xb4, 0x4c, 0xd1, 0xd2, 0x48, 0x08, 0xa0, 0xf8, 0x88, 0x00, 0xae, 0x12, 0x81, 0x05,   /*6351*/
0x42, 0x41, 0xc1, 0x49, 0x9a, 0x72, 0xa7, 0xc2, 0xa4, 0x52, 0x1a, 0x6b, 0x6c, 0xa4, 0x13, 0x0c,   /*6367*/
0x10, 0xa2, 0x7d, 0xac, 0xc3, 0x54, 0xd0, 0x1c, 0xc8, 0x88, 0x08, 0x25, 0xd7, 0x52, 0xb4, 0x52,   /*6383*/
0xa4, 0x62, 0xd9, 0x29, 0x36, 0x5f, 0x45, 0x10, 0x66, 0xdc, 0x50, 0xe3, 0x02, 0x40, 0xc8, 0x61,   /*6399*/
0xc7, 0x4a, 0xb3, 0x2e, 0xc5, 0xbe, 0x8d, 0x06, 0x42, 0x3c, 0xae, 0xb1, 0x10, 0xa5, 0xb4, 0x98,   /*6415*/
0x49, 0x24, 0x52, 0x1d, 0x1d, 0x60, 0xa4, 0xc0, 0x5d, 0xfd, 0x31, 0xbc, 0x52, 0x8c, 0x20, 0x93,   /*6431*/
0x11, 0x80, 0x04, 0x70, 0xb5, 0x24, 0x60, 0x9a, 0x21, 0xba, 0x58, 0x8d, 0x50, 0x88, 0x10, 0x45,   /*6447*/
0x04, 0x1c, 0xa8, 0x30, 0x00, 0x0b, 0x3a, 0x96, 0x89, 0x4d, 0x40, 0x9a, 0x94, 0x28, 0x18, 0x8b,   /*6463*/
0x63, 0x14, 0x00, 0x4b, 0x44, 0xa3, 0xa0, 0xa0, 0xc9, 0x08, 0x50, 0x89, 0x39, 0xe4, 0x8e, 0x20,   /*6479*/
0x27, 0x42, 0x80, 0x2a, 0xe9, 0x00, 0xfb, 0x87, 0xc0, 0x84, 0xa2, 0x08, 0xc5, 0x10, 0x08, 0x01,   /*6495*/
0x95, 0xc7, 0x10, 0x82, 0x1a, 0x22, 0xc6, 0x02, 0x50, 0xdd, 0x18, 0x22, 0xb8, 0x23, 0x68, 0xc0,   /*6511*/
0x0c, 0x08, 0x00, 0x89, 0x11, 0x38, 0x08, 0x90, 0x03, 0x24, 0x00, 0xe8, 0x40, 0x09, 0x12, 0x3a,   /*6527*/
0x09, 0x62, 0x30, 0x27, 0x04, 0x48, 0x30, 0x3c, 0x2e, 0x82, 0x41, 0xc0, 0x08, 0x40, 0x7d, 0x8d,   /*6543*/
0x6b, 0xd5, 0x29, 0x82, 0x1e, 0x06, 0x14, 0x4a, 0x44, 0x90, 0x09, 0x24, 0x54, 0xc1, 0x56, 0x8c,   /*6559*/
0x04, 0x84, 0x51, 0xc4, 0x34, 0x80, 0xc2, 0x20, 0x9a, 0x04, 0x00, 0x63, 0x8a, 0x00, 0x2d, 0x01,   /*6575*/
0x2d, 0x48, 0x80, 0x2b, 0x05, 0x00, 0x5d, 0xf2, 0x55, 0x90, 0x0f, 0x7e, 0xac, 0x55, 0x2c, 0x68,   /*6591*/
0x84, 0x2b, 0x95, 0x19, 0x22, 0x01, 0x02, 0x62, 0xd0, 0x76, 0xa4, 0x90, 0x20, 0x94, 0x0b, 0x90,   /*6607*/
0x24, 0x00, 0x07, 0x92, 0x04, 0x81, 0xb1, 0x24, 0x48, 0x80, 0x23, 0xe4, 0x88, 0x80, 0x72, 0x51,   /*6623*/
0x4d, 0x6c, 0xc9, 0x22, 0xa5, 0x20, 0xcd, 0xab, 0xfa, 0x55, 0x8c, 0x84, 0x35, 0xa9, 0x80, 0x8a,   /*6639*/
0xa4, 0x00, 0x9e, 0x08, 0x7a, 0xfb, 0x12, 0x8c, 0xa7, 0x4a, 0x91, 0x4a, 0xc7, 0xa8, 0x18, 0x99,   /*6655*/
0x83, 0x68, 0x11, 0x04, 0x2d, 0xc7, 0x70, 0xe8, 0xd8, 0x62, 0x51, 0xa4, 0x79, 0x54, 0x4c, 0xda,   /*6671*/
0x0c, 0x01, 0xc2, 0xa9, 0xcd, 0x6c, 0x93, 0x42, 0x30, 0xa9, 0xc0, 0x20, 0x4c, 0x6a, 0x28, 0xa0,   /*6687*/
0x13, 0x04, 0x01, 0x05, 0x10, 0x0d, 0x44, 0x20, 0xa2, 0x00, 0x10, 0xa0, 0x54, 0x82, 0x16, 0x80,   /*6703*/
0x90, 0x24, 0x58, 0x20, 0x01, 0x4c, 0x0c, 0x42, 0x10, 0x23, 0xd4, 0x50, 0x0d, 0x6d, 0xd3, 0x10,   /*6719*/
0x40, 0x8e, 0x80, 0x03, 0x64, 0x44, 0x0c, 0x52, 0x00, 0x5a, 0x60, 0x4d, 0x26, 0xcb, 0xcd, 0x39,   /*6735*/
0xa5, 0x59, 0x09, 0xc8, 0x63, 0x75, 0x07, 0x35, 0x05, 0x81, 0x4a, 0xa2, 0xec, 0xa0, 0x96, 0x15,   /*6751*/
0x94, 0xb3, 0x04, 0xad, 0x24, 0x04, 0x00, 0x3e, 0x6c, 0x2e, 0x10, 0x08, 0x4c, 0x0a, 0xbe, 0x3b,   /*6767*/
0xd4, 0x74, 0x2f, 0xc0, 0x51, 0x72, 0x44, 0x07, 0x12, 0x61, 0x46, 0xa0, 0x00, 0x43, 0x06, 0xb8,   /*6783*/
0x72, 0x32, 0xda, 0x14, 0x3a, 0x24, 0xb8, 0x1f, 0x5d, 0xc6, 0x36, 0xad, 0x50, 0x7d, 0x9e, 0x00,   /*6799*/
0x0a, 0x64, 0x8b, 0xf7, 0x27, 0x02, 0x76, 0x60, 0x80, 0x5e, 0x83, 0x11, 0x1f, 0xe8, 0x52, 0x80,   /*6815*/
0x81, 0x86, 0x24, 0x91, 0x08, 0x14, 0x4c, 0x2c, 0x14, 0x02, 0x8e, 0x94, 0x04, 0x00, 0x44, 0xc6,   /*6831*/
0x80, 0x45, 0x0b, 0x07, 0x0c, 0x01, 0x41, 0x44, 0x2e, 0xe2, 0x2b, 0x3b, 0x1d, 0x28, 0xc6, 0xbb,   /*6847*/
0x31, 0xa1, 0xea, 0x91, 0x88, 0xc9, 0x34, 0x30, 0xdd, 0x3b, 0x27, 0xe0, 0x27, 0xb4, 0xba, 0x9a,   /*6863*/
0x06, 0x30, 0x1c, 0x91, 0x15, 0x03, 0x09, 0x2d, 0xd4, 0x83, 0x14, 0x00, 0xba, 0x19, 0x04, 0x01,   /*6879*/
0x24, 0xc2, 0x10, 0xf0, 0x04, 0x24, 0x04, 0x00, 0x1b, 0x60, 0x20, 0x15, 0x08, 0x50, 0x01, 0x26,   /*6895*/
0x19, 0x09, 0x00, 0x91, 0x49, 0x24, 0x08, 0x00, 0x48, 0x06, 0x24, 0x60, 0x31, 0x00, 0x96, 0x66,   /*6911*/
0x40, 0x12, 0x00, 0x50, 0xc0, 0x24, 0x23, 0x00, 0x00, 0x02, 0x82, 0x04, 0x83, 0x68, 0x02, 0x00,   /*6927*/
0x04, 0xa1, 0x04, 0xa0, 0x12, 0x00, 0x01, 0x44, 0x22, 0x5d, 0xc9, 0xc4, 0x48, 0x30, 0x55, 0x01,   /*6943*/
0xe2, 0xa1, 0x84, 0x82, 0x18, 0x63, 0x55, 0x0a, 0x48, 0x9b, 0x98, 0x49, 0x61, 0x44, 0xc0, 0x38,   /*6959*/
0x21, 0x02, 0x81, 0x02, 0x80, 0x04, 0x44, 0x00, 0x0a, 0x31, 0xa6, 0x98, 0xc1, 0xc2, 0xab, 0x44,   /*6975*/
0xb1, 0x01, 0xac, 0x7b, 0x86, 0x14, 0x27, 0x7a, 0x90, 0x17, 0x14, 0x05, 0x90, 0x93, 0x00, 0x26,   /*6991*/
0xa0, 0x44, 0x50, 0x50, 0x00, 0x09, 0x82, 0x40, 0x10, 0x27, 0x40, 0x89, 0x00, 0x12, 0x09, 0x21,   /*7007*/
0x8d, 0x44, 0x10, 0x01, 0x40, 0x80, 0x80, 0x3b, 0x12, 0x2a, 0x01, 0x02, 0x34, 0x84, 0x02, 0x05,   /*7023*/
0xca, 0xc4, 0x88, 0xbe, 0xea, 0x13, 0x16, 0x7f, 0x66, 0x2e, 0x6d, 0x98, 0x13, 0x37, 0x41, 0x31,   /*7039*/
0xe0, 0x34, 0x04, 0x0d, 0x66, 0x6d, 0x72, 0x60, 0xaa, 0x97, 0x10, 0x2a, 0x63, 0x76, 0x74, 0x28,   /*7055*/
0x82, 0x30, 0xb8, 0xb0, 0x80, 0xa0, 0x60, 0x56, 0x02, 0x54, 0x31, 0x2c, 0x01, 0x4b, 0x30, 0x41,   /*7071*/
0x10, 0x80, 0xc9, 0x11, 0x05, 0xa0, 0x01, 0x00, 0x48, 0xb8, 0x40, 0x03, 0x00, 0x90, 0x40, 0x05,   /*7087*/
0x00, 0x24, 0x88, 0x08, 0x00, 0x82, 0x28, 0x38, 0x00, 0x01, 0x40, 0xe9, 0x40, 0x08, 0x24, 0x00,   /*7103*/
0x83, 0xbc, 0x05, 0x80, 0x02, 0x06, 0x08, 0x00, 0xa0, 0x49, 0x0a, 0x05, 0xc8, 0x30, 0x12, 0x20,   /*7119*/
0xac, 0x9c, 0x8b, 0x24, 0x53, 0x1b, 0x48, 0x11, 0x10, 0xb4, 0x09, 0x92, 0x80, 0x34, 0x1f, 0xeb,   /*7135*/
0x90, 0x40, 0x03, 0x00, 0x02, 0x20, 0x01, 0x5d, 0x11, 0x01, 0x42, 0xc0, 0x10, 0x04, 0x02, 0x98,   /*7151*/
0x24, 0x07, 0x43, 0x0c, 0x04, 0x03, 0x25, 0x2c, 0x34, 0x8a, 0xa0, 0x01, 0x20, 0xc6, 0x10, 0x84,   /*7167*/
0x11, 0x30, 0x0d, 0x63, 0xa4, 0x00, 0xdc, 0x63, 0x24, 0xd8, 0x82, 0x70, 0x03, 0x48, 0x86, 0x53,   /*7183*/
0x21, 0x69, 0x13, 0x23, 0x1c, 0x01, 0x91, 0xea, 0x89, 0x1c, 0x40, 0x43, 0x28, 0x00, 0x32, 0x94,   /*7199*/
0x41, 0x92, 0x11, 0xc2, 0x12, 0x10, 0x41, 0x03, 0x48, 0x9d, 0x0f, 0x22, 0xb6, 0x28, 0x2a, 0x02,   /*7215*/
0x09, 0x39, 0xa6, 0x06, 0x15, 0x20, 0x08, 0x04, 0x47, 0x16, 0x89, 0x12, 0x02, 0x80, 0xd9, 0x12,   /*7231*/
0x90, 0x32, 0xa8, 0x20, 0x92, 0x42, 0x00, 0x0f, 0x50, 0x88, 0x84, 0x00, 0x12, 0x46, 0x91, 0x38,   /*7247*/
0xca, 0x82, 0x09, 0x1a, 0x41, 0xa0, 0xb5, 0x10, 0x04, 0x42, 0x8f, 0x01, 0x4c, 0xfd, 0xe7, 0x03,   /*7263*/
0x21, 0x10, 0x08, 0xc3, 0x00, 0x8a, 0x1b, 0x20, 0x46, 0x83, 0x02, 0x3e, 0xb3, 0xd2, 0x0a, 0x9d,   /*7279*/
0x51, 0x1d, 0x0d, 0x9c, 0x96, 0x35, 0x10, 0x08, 0x3e, 0x52, 0x0b, 0x98, 0x48, 0xb7, 0x20, 0x80,   /*7295*/
0x59, 0xd8, 0x50, 0x23, 0x1b, 0x81, 0x8e, 0x23, 0x08, 0x82, 0x61, 0x0d, 0x00, 0x05, 0x18, 0xb3,   /*7311*/
0x18, 0x09, 0xc1, 0x02, 0x82, 0xe9, 0x6a, 0x04, 0x51, 0x31, 0x15, 0x04, 0x92, 0x88, 0x00, 0x3a,   /*7327*/
0x81, 0x01, 0x0b, 0x42, 0x91, 0x41, 0x00, 0x00, 0x00, 0x20, 0x55, 0x20, 0x12, 0x04, 0x00, 0x08,   /*7343*/
0x22, 0x2c, 0x01, 0x00, 0x08, 0x64, 0x94, 0x82, 0x53, 0x10, 0x19, 0x9d, 0x08, 0x12, 0xc3, 0x23,   /*7359*/
0x03, 0x00, 0xdb, 0x42, 0x2c, 0x24, 0x65, 0x86, 0x85, 0xa7, 0x07, 0x01, 0x27, 0x47, 0x1b, 0x41,   /*7375*/
0x90, 0x4e, 0x10, 0x80, 0x00, 0x04, 0x35, 0x22, 0x40, 0x40, 0x93, 0x55, 0x26, 0x0d, 0x6c, 0x72,   /*7391*/
0x19, 0xbc, 0x91, 0x41, 0x04, 0x88, 0xe4, 0x24, 0xa4, 0x62, 0x24, 0x82, 0x40, 0xa0, 0x24, 0x70,   /*7407*/
0x10, 0x43, 0x01, 0x00, 0x56, 0x91, 0x45, 0x70, 0x09, 0x10, 0x48, 0x22, 0x57, 0x1c, 0x2d, 0x2a,   /*7423*/
0x09, 0x40, 0x2a, 0x12, 0x21, 0x20, 0x11, 0x2a, 0xd5, 0xc2, 0x42, 0x26, 0x40, 0x41, 0x08, 0x56,   /*7439*/
0x1a, 0x61, 0x95, 0x54, 0x00, 0x98, 0x08, 0x60, 0xf3, 0x4d, 0xea, 0x41, 0x5c, 0x60, 0xa8, 0x6b,   /*7455*/
0xf0, 0x9d, 0x2c, 0xf6, 0x18, 0xf2, 0x40, 0x92, 0x98, 0x84, 0x44, 0x4c, 0x81, 0x1c, 0x42, 0x96,   /*7471*/
0xc9, 0xa5, 0xc1, 0xa6, 0x92, 0x96, 0x28, 0x9b, 0x68, 0xa5, 0xa0, 0x01, 0x2a, 0xc3, 0x22, 0xc8,   /*7487*/
0xa9, 0xb1, 0x71, 0x35, 0xf1, 0xfe, 0x36, 0x11, 0xa0, 0x12, 0x40, 0xc3, 0x46, 0x89, 0x01, 0x85,   /*7503*/
0x4c, 0x41, 0x00, 0x60, 0xe1, 0x54, 0x84, 0xd0, 0x87, 0xd4, 0xe8, 0x52, 0xc1, 0x40, 0x94, 0x49,   /*7519*/
0x00, 0xc2, 0x08, 0x02, 0x27, 0x68, 0xf6, 0x01, 0x6e, 0x4d, 0x37, 0x57, 0xe3, 0x22, 0xf0, 0x4c,   /*7535*/
0x08, 0x10, 0x2a, 0xa2, 0x42, 0x04, 0xb8, 0x15, 0x01, 0x41, 0x9d, 0x20, 0x40, 0x00, 0xa0, 0x6e,   /*7551*/
0x4b, 0x10, 0x60, 0x10, 0x00, 0x03, 0x47, 0x02, 0x5b, 0x00, 0xcb, 0x32, 0xc8, 0x10, 0x22, 0x83,   /*7567*/
0x80, 0x05, 0x04, 0x52, 0x0d, 0x00, 0x6b, 0x45, 0x06, 0x00, 0xc0, 0x41, 0x4b, 0x20, 0x86, 0x70,   /*7583*/
0xe3, 0x05, 0x10, 0x1e, 0x34, 0x6d, 0x35, 0x04, 0x0c, 0x08, 0x13, 0x0a, 0x03, 0x48, 0x01, 0x02,   /*7599*/
0x32, 0x81, 0x04, 0x31, 0x6c, 0x22, 0xf9, 0xb1, 0x68, 0x0e, 0x51, 0x22, 0x43, 0xc5, 0x0b, 0x10,   /*7615*/
0x66, 0x15, 0x31, 0x5c, 0x24, 0x34, 0xb1, 0x35, 0x7d, 0x01, 0x21, 0x5d, 0x80, 0xd6, 0x6e, 0x65,   /*7631*/
0x2c, 0x43, 0x34, 0x34, 0x8f, 0x08, 0xd9, 0x31, 0xe5, 0xc7, 0x03, 0x0c, 0x42, 0x59, 0xa8, 0x8b,   /*7647*/
0x0b, 0x04, 0x10, 0xae, 0x53, 0x1c, 0xe1, 0x38, 0x23, 0x6c, 0x90, 0x84, 0x02, 0x20, 0x89, 0x4c,   /*7663*/
0x24, 0x53, 0x51, 0x72, 0x7c, 0xb8, 0x41, 0x22, 0x82, 0x03, 0x21, 0x15, 0xaa, 0xe2, 0x8c, 0x37,   /*7679*/
0xa0, 0x83, 0x84, 0xf1, 0x50, 0x84, 0xa5, 0x90, 0xd8, 0xda, 0x4c, 0xb2, 0x26, 0xe5, 0x05, 0x2e,   /*7695*/
0x18, 0x18, 0x72, 0x06, 0x10, 0x34, 0x80, 0xa6, 0x77, 0xb0, 0x29, 0xa8, 0xfc, 0xb2, 0x75, 0x41,   /*7711*/
0xcc, 0xd5, 0xe8, 0xc3, 0x02, 0x48, 0x92, 0x38, 0x01, 0x5e, 0x94, 0x5e, 0x71, 0x05, 0xb3, 0x3d,   /*7727*/
0x44, 0x80, 0xcc, 0x5e, 0xc8, 0x2b, 0x0e, 0x2e, 0x82, 0x48, 0x28, 0xaa, 0x86, 0x79, 0x78, 0x71,   /*7743*/
0xa6, 0x90, 0x10, 0x00, 0x01, 0x66, 0x27, 0x42, 0x41, 0xc0, 0x88, 0x41, 0x24, 0x80, 0x41, 0xd0,   /*7759*/
0x38, 0x00, 0x2a, 0xa6, 0x0f, 0x04, 0x41, 0x95, 0xc0, 0xb5, 0x62, 0x15, 0x50, 0x28, 0xaa, 0x17,   /*7775*/
0x68, 0x20, 0x2a, 0x93, 0x1c, 0xc2, 0x76, 0xcb, 0x7d, 0xe8, 0x81, 0x45, 0xfe, 0xd1, 0x64, 0xcf,   /*7791*/
0x27, 0x0f, 0xda, 0xc6, 0x41, 0xb7, 0x40, 0x1c, 0xf4, 0xa1, 0x58, 0xb9, 0x26, 0xda, 0x19, 0x64,   /*7807*/
0x98, 0x64, 0x32, 0xa5, 0x51, 0x75, 0x82, 0x64, 0x19, 0xfa, 0x25, 0x46, 0xa3, 0x12, 0x16, 0xf5,   /*7823*/
0xac, 0x48, 0x06, 0xa6, 0x80, 0x52, 0x58, 0x04, 0x0e, 0x03, 0x80, 0x45, 0x26, 0x2a, 0x00, 0x2a,   /*7839*/
0x65, 0xc8, 0x02, 0x40, 0x14, 0xd3, 0xa2, 0x33, 0x12, 0xa0, 0x11, 0x5d, 0x0c, 0x01, 0xdb, 0x29,   /*7855*/
0x20, 0x41, 0x26, 0x14, 0x01, 0x24, 0x92, 0x48, 0x06, 0x65, 0x0e, 0x1d, 0xe7, 0x49, 0x8e, 0xe4,   /*7871*/
0x44, 0x21, 0x0d, 0xc4, 0x14, 0x2b, 0x60, 0x93, 0x17, 0x14, 0xed, 0xe7, 0x86, 0xdc, 0xcc, 0xc6,   /*7887*/
0x14, 0x08, 0x89, 0x40, 0x23, 0x95, 0xd8, 0x51, 0x3c, 0xe9, 0xda, 0xa6, 0x27, 0xa6, 0x65, 0x43,   /*7903*/
0x09, 0x00, 0x06, 0x00, 0x51, 0xeb, 0x00, 0x01, 0x82, 0x8e, 0x85, 0x14, 0x2c, 0x24, 0x61, 0x40,   /*7919*/
0xa9, 0x18, 0x61, 0x05, 0x08, 0x81, 0x22, 0x06, 0x40, 0x49, 0xc1, 0x12, 0x5a, 0x50, 0x10, 0x2b,   /*7935*/
0x63, 0x0f, 0x21, 0x00, 0x81, 0x8d, 0xb0, 0x45, 0x28, 0x4c, 0x98, 0x13, 0x4d, 0x86, 0xdb, 0x49,   /*7951*/
0x2a, 0x0f, 0xa0, 0x36, 0x08, 0x60, 0x57, 0x21, 0x52, 0x08, 0x4f, 0x59, 0x47, 0x62, 0x1d, 0x80,   /*7967*/
0xf6, 0xfb, 0x90, 0x60, 0xd0, 0x80, 0x03, 0x5c, 0x2a, 0xc3, 0x40, 0xe9, 0x72, 0xd8, 0x5d, 0x28,   /*7983*/
0x4b, 0x99, 0x18, 0xc1, 0x5d, 0x0d, 0x14, 0xe5, 0x30, 0x80, 0x2c, 0xcb, 0x21, 0x5c, 0x12, 0x0d,   /*7999*/
0xa0, 0xd3, 0x04, 0x2c, 0x2e, 0x41, 0xa0, 0x44, 0x55, 0x77, 0x21, 0x29, 0x01, 0x2b, 0x54, 0x89,   /*8015*/
0x00, 0x23, 0x40, 0x45, 0x54, 0x71, 0x11, 0xc5, 0x43, 0x52, 0x2a, 0x34, 0x28, 0xe8, 0x52, 0x49,   /*8031*/
0x0c, 0x20, 0x83, 0x84, 0x01, 0xd0, 0x35, 0xc0, 0xa0, 0x10, 0x28, 0x28, 0x0c, 0x17, 0x10, 0x34,   /*8047*/
0x9b, 0x1d, 0x36, 0xa3, 0xd6, 0xe1, 0xd1, 0x32, 0x06, 0x12, 0x42, 0x48, 0x10, 0x00, 0x70, 0x40,   /*8063*/
0x40, 0x10, 0x51, 0xf5, 0x3c, 0xf3, 0xac, 0x00, 0x14, 0x32, 0xc9, 0x2a, 0x83, 0x90, 0x13, 0x00,   /*8079*/
0xf0, 0x3a, 0x61, 0x22, 0x09, 0x28, 0x28, 0x10, 0x49, 0x00, 0x90, 0x4a, 0x51, 0x25, 0xdd, 0xdc,   /*8095*/
0x80, 0x84, 0x62, 0x9f, 0x54, 0xbc, 0x86, 0x00, 0x00, 0xa8, 0x35, 0x0c, 0x54, 0x42, 0xb4, 0x1c,   /*8111*/
0xc1, 0x28, 0x8a, 0xde, 0x26, 0x42, 0x1e, 0x7f, 0xd1, 0x55, 0x2c, 0xc5, 0x4c, 0x20, 0x49, 0x6d,   /*8127*/
0x40, 0x46, 0xaa, 0x84, 0xa0, 0x4b, 0x89, 0x05, 0x18, 0xa4, 0x8b, 0x02, 0x20, 0x40, 0x00, 0x20,   /*8143*/
0x04, 0x00, 0x08, 0x99, 0x4c, 0xcb, 0xa8, 0x8b, 0xb0, 0xd0, 0x92, 0xee, 0x1e, 0x51, 0x00, 0x44,   /*8159*/
0x39, 0x35, 0x13, 0x78, 0x05, 0x59, 0x7f, 0x31, 0x62, 0x93, 0x14, 0x10, 0x11, 0x20, 0x46, 0x88,   /*8175*/
0xa2, 0xc5, 0x18, 0x31, 0x84, 0x82, 0x1d, 0x98, 0x30, 0x28, 0x7d, 0x66, 0x90, 0x10, 0x12, 0x00,   /*8191*/
#endif
};
INT32U Test_BCH_Func(struct ScanDieInfo *sdi,INT16U Tmp)
{
	struct NandSpareData SData;
	INT32U ret, sublk ;
	INT8U *StrTmp;
        INT32U BitMap;

	INT32U iLoop;
	sublk =0x07;
	bPrintFlag =0x01;
	iLoop =0x00;
	SuBlkErase(sdi->DieNo, sublk);
	MEMCPY(GPageBuf,Const_Data,8192);	
	MEMSET((INT8U *)&SData, 0xff, sizeof(struct NandSpareData));
        BitMap =0xFFDF;
        SuBlkPageRead(sdi->DieNo, sublk, iLoop, BitMap, GPageBuf, &SData);	
        BitMap =0xFFCF;
        SuBlkPageRead(sdi->DieNo, sublk, iLoop, BitMap, GPageBuf, &SData);	
        BitMap =0xFFEF;
        SuBlkPageRead(sdi->DieNo, sublk, iLoop, BitMap, GPageBuf, &SData);	

        BitMap =0xFFFE;
        SuBlkPageRead(sdi->DieNo, sublk, iLoop, BitMap, GPageBuf, &SData);	
        
        BitMap =0x7FFE;
        SuBlkPageRead(sdi->DieNo, sublk, iLoop, BitMap, GPageBuf, &SData);	

        BitMap =0xEFFE;
        SuBlkPageRead(sdi->DieNo, sublk, iLoop, BitMap, GPageBuf, &SData);	
        
	SData.UserData[0].SpareData0.BadFlag =0xFF;// 1Byte 
	SData.UserData[0].SpareData0.LogicBlkInfo =(0x00)<<8 | 0x00; // 2Byte 
	SData.UserData[0].SpareData1.LogicPageNum=(0x00)<<8|0x00; // 2Byte 
	SData.UserData[0].SpareData1.LogStatus.PhyPageStatus = 0x00;// 1Byte
	
	SuBlkPageWrite(sdi->DieNo, sublk, iLoop, SECTOR_BITMAP_FULLPLANE, GPageBuf, &SData);	
	SuBlkPageRead(sdi->DieNo, sublk, iLoop, SECTOR_BITMAP_FULLPLANE, GPageBuf, &SData);	
#if 1	
	sublk =0x078b;
	SuBlkErase(sdi->DieNo, sublk);
	iLoop =0x00;
	 MEMSET((INT8U *)&SData, 0xff, sizeof(struct NandSpareData));
	
//	 MEMCPY(GPageBuf,(INT8U*)&Const_Data[4096],4096);	
	SData.UserData[0].SpareData0.BadFlag =0xFF;// 1Byte 
	SData.UserData[0].SpareData0.LogicBlkInfo =(0x00)<<8 | 0x00; // 2Byte 
	SData.UserData[0].SpareData1.LogicPageNum=(0x00)<<8|0x00; // 2Byte 
	SData.UserData[0].SpareData1.LogStatus.PhyPageStatus = 0x00;// 1Byte
	 
	 SuBlkPageWrite(sdi->DieNo, sublk, iLoop, SECTOR_BITMAP_FULLPLANE, GPageBuf, &SData);	
	 SuBlkPageRead(sdi->DieNo, sublk, iLoop, SECTOR_BITMAP_FULLPLANE, GPageBuf, &SData);	

#endif	 
}

INT32U Test_Flash_ReadWrite(struct ScanDieInfo *sdi,INT16U Tmp)
{
	struct NandSpareData SData;
	INT32U ret, sublk;
	INT16U LogicBlkInfo;
	INT32U Bitmap;
	INT32U iLoop,DataCnt,kLoop;


	DMSG(DBL_LOG, "[SCAN] %s: (DieNo: %u) enter.\n", __FUNCTION__, sdi->DieNo);
	for (sublk = 0x08; sublk < (INT32S)BLK_CNT_PER_DIE; sublk++)
	{
		SuBlkErase(sdi->DieNo, sublk);

		DataCnt = SECTOR_NUM_PER_SINGLE_PAGE*NAND_SECTOR_SIZE;
		MEMCPY(GPageBuf,Const_Data,DataCnt);	
		
		 if((sublk%4)==0x00)
		 {
			 INIT_BOOT(" %4d  ",sublk);
			 if((sublk%48) ==0x00)
			 {
			 	INIT_BOOT("Loop:%d\n",Tmp);
			 }
		 }
		MEMSET((INT8U *)&SData, 0xff, sizeof(struct NandSpareData));
		 for(iLoop =0x00;iLoop<PAGE_CNT_PER_PHY_BLK;iLoop++)
		 {
			SData.UserData[0].SpareData1.LogicPageNum=iLoop;
			SData.UserData[0].SpareData1.LogStatus.PhyPageStatus = 0x55;	
			SData.UserData[0].SpareData0.LogicBlkInfo =0x8000 | (0x01 << 10) | 0xaa;	
			for(kLoop=0x00;kLoop <SECTOR_NUM_PER_SINGLE_PAGE;kLoop++)
			{
				GPageBuf[0x00+512*kLoop] =0x55;
				GPageBuf[0x01+512*kLoop] =0xAA;
				GPageBuf[0x02+512*kLoop] =iLoop;
				GPageBuf[0x03+512*kLoop] =0x55;
				GPageBuf[0x04+512*kLoop] =0xAA;
			}
			
		 	ret = SuBlkPageWrite(sdi->DieNo, sublk, iLoop, SECTOR_BITMAP_FULLPLANE, GPageBuf, &SData);	
		 }		
		 for(iLoop =0x00;iLoop<PAGE_CNT_PER_PHY_BLK;iLoop++)
		 {
		 
			for(kLoop=0x00;kLoop <SECTOR_NUM_PER_SINGLE_PAGE;kLoop++)
			{
				GPageBuf[0x00+512*kLoop] =0x55;
				GPageBuf[0x01+512*kLoop] =0xAA;
				GPageBuf[0x02+512*kLoop] =iLoop;
				GPageBuf[0x03+512*kLoop] =0x55;
				GPageBuf[0x04+512*kLoop] =0xAA;
			}
			//GPageBuf[0x08] =iLoop;		
			MEMSET(PHY_TMPBUF,0xff,DataCnt);
		 	ret = SuBlkPageRead(sdi->DieNo, sublk, iLoop, SECTOR_BITMAP_FULLPLANE, PHY_TMPBUF, &SData);
			if(MEMCMP(GPageBuf,PHY_TMPBUF,DataCnt))
			{
				INIT_BOOT("run to :%s,%d error : Page:%d\n",__func__,__LINE__,iLoop);	
				Str_printf("Write \n",GPageBuf,DataCnt);
				Str_printf("REad\n",PHY_TMPBUF,DataCnt);
			}
			
		 }
		 SuBlkErase(sdi->DieNo, sublk);
		 
		
	}
}

INT32U Test_Flash_ReadBlock(struct ScanDieInfo *sdi,INT16U Tmp)
{
	struct NandSpareData SData;
	INT32U ret, sublk;
	INT16U LogicBlkInfo;
	INT32U Bitmap;
	INT32U iLoop,DataCnt,kLoop;


	DMSG(DBL_LOG, "[SCAN] %s: (DieNo: %u) enter.\n", __FUNCTION__, sdi->DieNo);
	//_Short_DelayUS(1000*200);
	for(sublk = 0x785;sublk<=0x785;sublk++)
	{
		INIT_BOOT("###Block:%d  ###\n",sublk);	
		for(iLoop =0x00;iLoop<PAGE_CNT_PER_PHY_BLK;iLoop++)
		{
			INIT_BOOT("###Page:%d  ###\n",iLoop);	
			DataCnt = SECTOR_NUM_PER_SINGLE_PAGE*NAND_SECTOR_SIZE;
			MEMSET((INT8U *)&SData, 0xff, sizeof(struct NandSpareData));
			ret = SuBlkPageRead(sdi->DieNo, sublk, iLoop, SECTOR_BITMAP_FULLPLANE, PHY_TMPBUF, &SData);
			//if(MEMCMP(GPageBuf,PHY_TMPBUF,DataCnt))
			//if(!check_all_ff(PHY_TMPBUF,DataCnt))
			{
							
			 	Str_printf("REad\n",PHY_TMPBUF,128);
				/////Str_printf(" ",(INT8U *)&SData,sizeof(struct NandSpareData));
				
			}
			Str_printf(" ",(INT8U *)&SData,sizeof(struct NandSpareData));

		}

	}


	
	
}
INT32U Test_Flash_ReadSpare(struct ScanDieInfo *sdi,INT16U Tmp)
{
	struct NandSpareData SData;
	INT32U ret, sublk;
	INT16U LogicBlkInfo;
	INT32U Bitmap;
	INT32U iLoop,DataCnt,kLoop;


	DMSG(DBL_LOG, "[SCAN] %s: (DieNo: %u) enter.\n", __FUNCTION__, sdi->DieNo);
	for (sublk = 0x08; sublk < (INT32S)BLK_CNT_PER_DIE; sublk++)
	{
	
		 if((sublk%4)==0x00)
		 {
			 INIT_BOOT(" %4d  ",sublk);
			 if((sublk%48) ==0x00)
			 {
			 	INIT_BOOT("Loop:%d\n",Tmp);
			 }
		 }		
		 INIT_BOOT("\n\n###   run to :Blk %d ####\n",sublk);	
		 for(iLoop =0x00;iLoop<PAGE_CNT_PER_PHY_BLK;iLoop++)
		 {
		 	MEMSET((INT8U *)&SData, 0xff, sizeof(struct NandSpareData));
		 	ret = SuBlkPageRead(sdi->DieNo, sublk, iLoop, SECTOR_BITMAP_FULLPLANE, PHY_TMPBUF, &SData);
			INIT_BOOT("Page:%d",iLoop);
			Str_printf(" ",(INT8U *)&SData,sizeof(struct NandSpareData));
			
		 }
		 
		
	}
	return 0x00;
}

INT32U Driver_Test_Entry(struct ScanDieInfo *sdi)
{
	struct NandSpareData SData;
	INT32U ret, sublk, ZoneInDie, ZoneInFlash;
	INT32U ZoneTblStartPage, TblSize;
	INT16U LogicBlkInfo, chksum1, chksum2;
	INT16U TmpZoneInFlash;
	INT32U chksum1_32, chksum2_32;
	INT32U Bitmap;
	INT32U iLoop;
#if 1
        for(sublk=0x09;sublk<10;sublk++)
            Entry_Phy_ReadWholePage(sublk,0,1,PHY_TESTBUF);   
        sublk =10;
        SuBlkErase(sdi->DieNo, sublk);
        for(iLoop=0x00;iLoop<17;iLoop++)
        {
         ///   MEMSET(PHY_TESTBUF+iLoop*512,0x55+iLoop,512);
        }
         Str_printf("",PHY_TESTBUF,32);
         for(iLoop=0x00;iLoop<9;iLoop++)
         {
            *(INT8U*)(PHY_TESTBUF+iLoop) =iLoop;           
        }
        Str_printf("",PHY_TESTBUF,32);
        Entry_Phy_WriteWholePage(sublk,0,1,PHY_TESTBUF);  
        Entry_Phy_ReadPage(sublk,0,1,PHY_TESTBUF);  
         
        return FALSE;
        
#endif
	

	Test_Flash_ReadBlock(sdi,00);
 	return FALSE;

	for(iLoop =0x00;iLoop <300;iLoop++)
	{
		INIT_BOOT("#####run to:%s,%d#####\n",__func__,__LINE__);
		Test_Flash_ReadWrite(sdi,iLoop);
	}


	Test_BCH_Func(sdi,0x00);
 	return FALSE;
 	///Test_Flash_ReadSpare(sdi,0x00);
	//return FALSE;
	// sublk =0x78b;
	//bPrintFlag =0x01;
	//ret = SuBlkPageRead(sdi->DieNo, sublk, 0x00, SECTOR_BITMAP_FULLPLANE, GPageBuf, &SData);	
	
	//return FALSE;
 //	bPrintFlag =0x01;
 	sublk =0x07;
	SuBlkErase(sdi->DieNo, sublk);
	 for(iLoop=0x00;iLoop<(INT32U)(NandStorageInfo.SectorNumPerPage*128);iLoop++)
          {
                         *(INT32U*)(GPageBuf+iLoop*4)=0x12345678+iLoop*10;
          }
	 printf("Start Delayx\n");
	 MEMSET((INT8U *)&SData, 0xff, sizeof(struct NandSpareData));
	 for(iLoop =0x00;iLoop<32;iLoop++)
	 {
		SData.UserData[0].SpareData1.LogicPageNum=iLoop;
		SData.UserData[0].SpareData1.LogStatus.PhyPageStatus = 0x55;	
		SData.UserData[0].SpareData0.LogicBlkInfo =BLOCK_TYPE_SPECIAL | (0x01 << 10) | 0xaa;	
	//	SData.UserData[1].SpareData1.LogicPageNum=iLoop;
	//	SData.UserData[1].SpareData1.LogStatus.PhyPageStatus = 0x55;	
	//	SData.UserData[1].SpareData0.LogicBlkInfo =BLOCK_TYPE_SPECIAL | (0x01 << 10) | 0xaa;
		MEMCPY(GPageBuf,Const_Data,2048);
		GPageBuf[0x00] =0x55;
		GPageBuf[0x01] =0xAA;
		GPageBuf[0x02] =iLoop;		
		
		Str_printf(" ",(INT8U *)&SData,sizeof(struct NandSpareData));
	 	ret = SuBlkPageWrite(sdi->DieNo, sublk, iLoop, SECTOR_BITMAP_FULLPLANE, GPageBuf, &SData);	
	 }
	 printf("Start Delayx\n");
	  MEMSET((INT8U *)&SData, 0xff, sizeof(struct NandSpareData));
	 for(iLoop =0x00;iLoop<32;iLoop++)
	 {
	 	ret = SuBlkPageRead(sdi->DieNo, sublk, iLoop, SECTOR_BITMAP_FULLPLANE, PHY_TMPBUF, &SData);	
		
		Str_printf(" ",(INT8U *)&SData,sizeof(struct NandSpareData));
	 }
	 SuBlkErase(sdi->DieNo, sublk);
	 bPrintFlag =0x00;
	 return FALSE;

	printf("Start Delay\n");
	//_Short_DelayUS(1000*200);
	bPrintFlag =0x01;
	sublk =0x08;
	MEMSET((INT8U *)&SData, 0xff, sizeof(struct NandSpareData));
	ret = SuBlkPageRead(sdi->DieNo, sublk, 0, 0xFE, GPageBuf, &SData);
	ret = SuBlkPageRead(sdi->DieNo, sublk, 1, 0x7FE, GPageBuf, &SData);
	ret = SuBlkPageRead(sdi->DieNo, sublk, 0, 0xf003, GPageBuf, &SData);
	sublk =0x09;
	ret = SuBlkPageRead(sdi->DieNo, sublk, 0, 0x0e, GPageBuf, &SData);
	sublk =0x0a;
	ret = SuBlkPageRead(sdi->DieNo, sublk, 0, 0x7e, GPageBuf, &SData);
	sublk =0x09;
	SuBlkErase(sdi->DieNo, sublk);
	 for(iLoop=0x00;iLoop<(INT32U)(NandStorageInfo.SectorNumPerPage*128);iLoop++)
          {
                         *(INT32U*)(GPageBuf+iLoop*4)=0x12345678+iLoop*10;
          }
	 printf("Start Delayx\n");
	//_Short_DelayUS(1000*200);
	MEMSET((INT8U *)&SData, 0xff, sizeof(struct NandSpareData));
//	SData.UserData[0].LogicPageNum=0x01;
//	SData.UserData[0].LogStatus.PhyPageStatus = 0x55;	
//	SData.UserData[0].LogicBlkInfo =BLOCK_TYPE_SPECIAL | (0x01 << 10) | 0xaa;	
	ret = SuBlkPageWrite(sdi->DieNo, sublk, 0x00 + ZONETBL_OFFSET, SECTOR_BITMAP_FULLPLANE, GPageBuf, &SData);

	ret = SuBlkPageRead(sdi->DieNo, sublk, 0, SECTOR_BITMAP_BBF, GPageBuf, &SData);
	 Str_printf(" ",(INT8U *)&SData,sizeof(struct NandSpareData));	
	 return FALSE;

}








#endif
/**
 * \brief  Search the zone tables in die
 *
 * This routine searchs the zone tables of this die in flash.If found a valid zone table,
 * fills the zone table postion infomation to <NandDevInfo.ZoneInfo> structure and sets
 * the <ScanDieInfo.ValidZoneTblFlag>. If at least one zone table is not found or checksum
 * error, return FALSE.
 *
 * \param[in]  sdi The ScanDieInfo Pointer of die
 *
 * \return  result of searching zone tables
 *  - TRUE: Found all zone tables of this die
 *  - FALSE: At least one zone table is not be found or not valid.
 */
static INT32U ScanSearchZoneTbls(struct ScanDieInfo *sdi)
{
	struct NandSpareData SData;
	INT32U ret, sublk, ZoneInDie, ZoneInFlash;
	INT32U ZoneTblStartPage, TblSize;
	INT16U LogicBlkInfo, chksum1, chksum2;
	INT16U TmpZoneInFlash;
	INT32U chksum1_32, chksum2_32;
	INT32U Bitmap;
	INT32U iLoop;
	chksum1 = chksum2 =0x00;
	TmpZoneInFlash=chksum1_32= chksum2_32=0x00;
	DMSG(DBL_LOG, "[SCAN] %s: (DieNo: %u) enter.\n", __FUNCTION__, sdi->DieNo);
	
 #if   _TEST_HW_PageCTL_ && FWSC_DRIVER==0x01
 	Driver_Test_Entry(sdi);
 	return FALSE;
#endif

        /* repeat read blocks of this die to find zone tables */
	for (sublk = DIE_FIRST_SUBLK_NUM; sublk < MAX_ZONETBL_AREA_BLOCK; sublk++)
	{
		MEMSET((INT8U *)&SData, 0xff, sizeof(struct NandSpareData));
		////printf("GPageBuf:%x\n",(INT32U)GPageBuf);
		ret = SuBlkPageRead(sdi->DieNo, sublk, 0, SECTOR_BITMAP_BBF, GPageBuf, &SData);

		LogicBlkInfo = SData.UserData[0].SpareData0.LogicBlkInfo;

		/* check if it is a zonetable block */
		if ((SData.UserData[0].SpareData0.BadFlag != BAD_BLK_FLAG) 		/* not bad block */
			|| !(LogicBlkInfo & BLOCK_TYPE_SPECIAL) 	/* specical block */
			|| ((LogicBlkInfo & BLOCK_TYPE_MASK) != BLOCK_TYPE_ZONETBL))	/* zone table block */
		{
			continue;
		}

                
		ZoneInDie = (LogicBlkInfo >> 10)  & 0x0f;

		/* validate the zone number */
		if (ZoneInDie > ZONENUM_PER_DIE)
		{
			DMSG(DBL_WARNING, "[SCAN] %s: ZoneInDie %d of SuBlk %u exceed limit.\n",
					__FUNCTION__, ZoneInDie, sublk);

			SuBlkErase(sdi->DieNo, sublk);
			continue;
		}

		/* check if already has a zonetable block for this zone */
		ZoneInFlash = ZONENO_IN_FLASH(sdi->DieNo, ZoneInDie);
		if (NandDevInfo.ZoneInfo[ZoneInFlash].PhyBlkNum != 0xffff)
		{
			DMSG(DBL_WARNING, "[SCAN] %s: ZoneInfo[%d,%d,%d] already initialized, erase it!\n",
					__FUNCTION__, ZoneInFlash,ZoneInDie,sublk);

			SuBlkErase(sdi->DieNo, sublk);
			continue;
		}

		/* check if has a valid zone table in this block */
		ZoneTblStartPage = GetLastZoneTblPage(sdi->DieNo, sublk);
		INIT_DBG("ZoneTblStartPage:%d\n",ZoneTblStartPage);

		/* set the zone table postion infomation */
		NandDevInfo.ZoneInfo[ZoneInFlash].PhyBlkNum= sublk;
		NandDevInfo.ZoneInfo[ZoneInFlash].TablePosition = ZoneTblStartPage;
                     

		/* check the dirty flag */
		ret = SuBlkPageRead(sdi->DieNo, sublk, ZoneTblStartPage + PAGE_OFFSET_DIRTYFLAG, SECTOR_BITMAP_DIRTYFLAG, GPageBuf, NULL);
		if (GPageBuf[0] != 0xff)
                   {
			DMSG(DBL_INFO, "[SCAN] %s: Zone table %d has dirty flag for die %d at block %d.\n",
				__FUNCTION__, ZoneInDie, sdi->DieNo, sublk);

			continue;
		}


		if(SECTOR_NUM_PER_SINGLE_PAGE ==Page_Size2K) //Page 2KB 
		{
			Bitmap = SECTOR_BITMAP_ZONETBL;
		}
		else
		{
			Bitmap = BITMAP_ZONETBL_4K;
		}  

		/* check the zone table checksum */
		//Read 4KB Page                
		ret = SuBlkPageRead(sdi->DieNo, sublk, ZoneTblStartPage + ZONETBL_OFFSET, Bitmap, GPageBuf, NULL);

#if _NEW_ZONE_TBL_==0x01
		if(SECTOR_NUM_PER_SINGLE_PAGE ==Page_Size2K) //Page 2KB 
		{
			ret = SuBlkPageRead(sdi->DieNo, sublk, ZoneTblStartPage + ZONETBL_OFFSET+1, Bitmap, GPageBuf+2048, NULL); 
		}
		TblSize = (BLK_NUM_PER_ZONE - 1) * sizeof(INT32U);		
		chksum1_32 = *(INT32U *)(GPageBuf + TBL_CHKSUM_OFF_4K);
		chksum2_32 = _GetCheckSum32((INT32U *)GPageBuf, TblSize / sizeof(INT32U));
		if (chksum1_32 != chksum2_32)
		{
			DMSG(DBL_WARNING, "[SCAN] %s: Zone table %d checksum errorfor die %d at block %d.\n",
			__FUNCTION__, ZoneInDie, sdi->DieNo, sublk);
			continue;
		}
#else
		TblSize = (BLK_NUM_PER_ZONE - 1) * sizeof(INT16U);		
		chksum1 = *(INT16U *)(GPageBuf + TBL_CHKSUM_OFF_2K);
		chksum2 = _GetCheckSum((INT16U *)GPageBuf, TblSize / sizeof(INT16U)); 
		if (chksum1 != chksum2)
		{
			DMSG(DBL_WARNING, "[SCAN] %s: Zone table %d checksum errorfor die %d at block %d.\n",
			__FUNCTION__, ZoneInDie, sdi->DieNo, sublk);
			continue;
		}

#endif


		/* check the log block table checksum */

		ret = SuBlkPageRead(sdi->DieNo, sublk, ZoneTblStartPage + LOGTBL_OFFSET, SECTOR_BITMAP_ZONETBL, GPageBuf, NULL);

		TblSize = MAX_LOG_BLK_NUM * sizeof(struct LogBlkTblType);
		chksum1 = *(INT16U *)(GPageBuf + TABLE_CHKSUM_OFFSET);
		chksum2 = _GetCheckSum((INT16U *)GPageBuf, TblSize / sizeof(INT16U));
		if (chksum1 != chksum2)
		{
			DMSG(DBL_WARNING, "[SCAN] %s: Zone table %d LogBlkTbl checksum errorfor die %d at block %d.\n",
				__FUNCTION__, ZoneInDie, sdi->DieNo, sublk);

			continue;
		}

		/* OK, we find a valid zone table, now set the valid flag in ScanDieInfo structure */
		sdi->ValidZoneTblFlag[ZoneInDie] = 1;

#ifdef DBG_ALWAYS_REBUILD_ZONETBLS

		INIT_DBG("zone %d log block table\n:", ZoneInDie);
		dump_mem(GPageBuf, TblSize, 0, 2);

		/* set one sector dirty flag */
		MEMSET(GPageBuf, 0x55, 512);

		/* set the spare data of zone table page */
		MEMSET((INT8U *)&SData, 0xff, sizeof(struct NandSpareData));

		SData.UserData[0].SpareData1.LogStatus.PhyPageStatus = PAGE_STATE_USED;


		/* write zone table */
		ret = SuBlkPageWrite(sdi->DieNo, sublk, ZoneTblStartPage + PAGE_OFFSET_DIRTYFLAG, SECTOR_BITMAP_FULLPLANE, GPageBuf, &SData);

		//debug only
		sdi->ValidZoneTblFlag[ZoneInDie] = 0;
#endif

		//DMSG(DBL_INFO, "%s: [SCAN] Found valid zone table %d for die %d at block %d, page %d.\n",
		//	__FUNCTION__, ZoneInDie, sdi->DieNo, sublk, ZoneTblStartPage);
		INIT_BOOT("%s: [SCAN] Found valid zone table %d for die %d at block %d, page %d.\n",
				__FUNCTION__, ZoneInDie, sdi->DieNo, sublk, ZoneTblStartPage);		
	}	

	/* check if has not found all zone table */
	for (ZoneInDie = 0; ZoneInDie < ZONENUM_PER_DIE; ZoneInDie++)
	{
		if (!sdi->ValidZoneTblFlag[ZoneInDie])
		{
			DMSG(DBL_LOG, "[SCAN] %s: (DieNo: %u) out, ret %d\n", __FUNCTION__, sdi->DieNo, FALSE);
			return FALSE;
		}
	}

	DMSG(DBL_LOG, "[SCAN] %s: (DieNo: %u) out, ret %d\n", __FUNCTION__, sdi->DieNo, TRUE);

	return TRUE;
}

/**
 * \brief  Allocate memory for scan module
 *
 * \param[in]  sdi The ScanDieInfo Pointer
 *
 * \return  result of allocate memory
 *  - TRUE: Succeeded to allocate memory
 *  - FALSE: Failed to allocate memory
 */
static INT32S ScanInitMemory(struct ScanDieInfo *sdi)
{
	INT32S ret = 0;

	DMSG(DBL_LOG, "[SCAN] ScanInitMemory() enter.\n");

	sdi->PhyBlkArray = (INT16U*)MALLOC(SUBLK_PER_DIE * sizeof(INT16U));
	if (!sdi->PhyBlkArray) {
		ret = -SCAN_ERR_NO_MEM;
		goto out;
	}
	MEMSET(sdi->PhyBlkArray, 0xff, SUBLK_PER_DIE * sizeof(INT16U));
	//printf("sdi->PhyBlkArray :%x\n",sdi->PhyBlkArray );

	sdi->ZoneInfos = (struct ScanZoneInfo *)MALLOC(ZONENUM_PER_DIE * sizeof(struct ScanZoneInfo));
	if (!sdi->ZoneInfos) {
		ret = SCAN_ERR_NO_MEM;
		goto out;
	}

out:
	if (ret)
	{
		/* failed, simply free memory */
		ScanFreeMemory(sdi);
	}
	else
	{
		/* init <ScanZoneInfo> */
		struct ScanZoneInfo *szi;
		INT32S i;

		for (i = 0; i < (INT32S)ZONENUM_PER_DIE; i++) {
			szi = &sdi->ZoneInfos[i];

			szi->DataBlkCnt = 0;
			szi->LogBlkCnt = 0;
			szi->FreeBlkCnt = 0;
			szi->FreeBlkInex = 0;
			MEMSET(&szi->ZoneTbl, 0xff, sizeof(szi->ZoneTbl));
			MEMSET(&szi->LogBlkTbl, 0xff, sizeof(szi->LogBlkTbl));
		}
	}

	DMSG(DBL_LOG, "[SCAN] ScanInitMemory() out, ret %d.\n", ret);

	return ret;
}

/**
 * \brief  Free memory for scan module
 *
 * \param[in]  sdi The ScanDieInfo Pointer
 *
 * \return  NULL
 */
static void ScanFreeMemory(struct ScanDieInfo *sdi)
{
	if (sdi->PhyBlkArray)
	{
		FREE(sdi->PhyBlkArray)	;
		sdi->PhyBlkArray = NULL;
	}

	if (sdi->ZoneInfos)
	{
		FREE(sdi->ZoneInfos);
		sdi->ZoneInfos = NULL;
	}
}


/**
 * \brief  Caculate the constants for scan module
 *
 * \param: NULL
 *
 * \return: NULL
 */
void CaclConsts(void)
{
	/* default bank count is 1 */
	TOTAL_BANKS = 1;

	DIENUM_IN_FLASH = (NandDevInfo.NandFlashInfo->ChipCnt)
		* (NandDevInfo.NandFlashInfo->DieCntPerChip);

	if (NAND_SUPPORT_INTERNAL_INTERLEAVE)
	{
		TOTAL_BANKS *= (NandDevInfo.NandFlashInfo->BankCntPerChip);
		DIENUM_IN_FLASH /= NandDevInfo.NandFlashInfo->BankCntPerChip;
	}

	if (NAND_SUPPORT_EXTERNAL_INTERLEAVE)
	{
	    TOTAL_BANKS *= NandDevInfo.NandFlashInfo->ChipCnt;
		DIENUM_IN_FLASH /= NandDevInfo.NandFlashInfo->ChipCnt;
		//INIT_DBG("NAND_SUPPORT_EXTERNAL_INTERLEAVE\n");
	}

	ZONENUM_PER_DIE = (NandDevInfo.LogicOrganizePar->ZoneNumPerDie);
	SUBLK_PER_DIE = (ZONENUM_PER_DIE * BLK_NUM_PER_ZONE);

	PAGES_PER_SUBLK = NandDevInfo.LogicOrganizePar->PageNumPerLogicBlk;

	MULTI_PLANE_SUPPORT =
		(NandDevInfo.NandFlashInfo->OperationOpt & MULTI_PAGE_WRITE) ? 1 : 0;

                DIE_FIRST_SUBLK_NUM = SECTORS_TO_BLOCKS(1) * MBRC_MAX_UNITS \                        
                                + SECTORS_TO_BLOCKS(BREC_SECTOR_NUM) * MBRC_MAX_UNITS;
/*        if(MULTI_PLANE_SUPPORT)
        {
                    DIE_FIRST_SUBLK_NUM/=2;
        }*/

	DMSG(DBL_INFO, "TOTAL_BANKS          %u\n", TOTAL_BANKS);
	DMSG(DBL_INFO, "DIENUM_IN_FLASH      %u\n", DIENUM_IN_FLASH);
	DMSG(DBL_INFO, "ZONENUM_PER_DIE      %u\n", ZONENUM_PER_DIE);
	DMSG(DBL_INFO, "SUBLK_PER_DIE        %u\n", SUBLK_PER_DIE);
	DMSG(DBL_INFO, "PAGES_PER_SUBLK      %u\n", PAGES_PER_SUBLK);
	DMSG(DBL_INFO, "MULTI_PLANE_SUPPORT  %u\n", MULTI_PLANE_SUPPORT);
	DMSG(DBL_INFO, "DIE_FIRST_SUBLK_NUM  %u\n", DIE_FIRST_SUBLK_NUM);
	
}

 /**
 * \brief  Initialize the zone tables
 *
 * This routine
 * a) probes the flash arrays which connected, and fills the <NandDev> structure
 *    by physical flash infomation
 * b) search zone tables in flash, and filled their postion into <NandDev.ZoneInfo> structure
 * c) if not searched all zone tables in flash, then rebuid them and write to flash.
 *
 * \return  the result
 *  - TRUE Succeeded to create zone tables
 *  - FALSE Failed to create zone tables
 */
INT32U INIT_CreateBlkTbls(void)
{
        struct ScanDieInfo *sdi;
        INT32U DieNo;
        INT32U ret = TRUE;

        DMSG(DBL_LOG, "[INIT] INIT_CreateBlkTbls() enter.\n");

        DASSERT(NandDevInfo.ZoneInfo);
        DASSERT(NandDevInfo.NandFlashInfo);
        DASSERT(NandDevInfo.LogicOrganizePar);

        /* init heap for nand flash driver */
        
         init_heap_for_nand();
      
        ret = INIT_ScanNandStorage();
        if (ret != TRUE)
        {
                DMSG(DBL_ERR, "[INIT] NandProbe err, ret %u\n", ret);
                goto failed;
        }             
        CaclConsts();

        sdi = &DieInfo;
        /* allocate global page buffer */
        if(NandDevInfo.LogicOrganizePar->SectorNumPerLogicPage<=Page_Size2K) //Page 2KB 
        {
                GPageBuf = (INT8U*)MALLOC(NandDevInfo.LogicOrganizePar->SectorNumPerLogicPage * NAND_SECTOR_SIZE*2);
        }
        else
        {
                GPageBuf = (INT8U*)MALLOC(NandDevInfo.LogicOrganizePar->SectorNumPerLogicPage * NAND_SECTOR_SIZE);
        }   
        if (!GPageBuf)
        {
                ret = SCAN_ERR_NO_MEM;
                goto failed;
        }
        NandDevInfo.PhyCache =  (INT8U*)MALLOC(SECTOR_NUM_PER_SINGLE_PAGE* NAND_SECTOR_SIZE);
        NandDevInfo.TestBuf=  (INT8U*)MALLOC((SECTOR_NUM_PER_SINGLE_PAGE+2)* NAND_SECTOR_SIZE);
        INIT_DBG("###NandDevInfo.PhyCache :%x ,size:%d\n",(INT32U)NandDevInfo.PhyCache ,SECTOR_NUM_PER_SINGLE_PAGE* NAND_SECTOR_SIZE);
        INIT_DBG("###GPageBuf:0x%x\n",(INT32U)GPageBuf);
#if (defined(__KERNEL__)   || BREC_DRIVER == 0x01)		
	Set_TestBuf();
#endif

      //@fish add Erase ALL Block
#if ODFACT_EraseALL_Block==0x01 && 0x01 ==ODFACT_ENABLE	
         NF_Eraseblk_Verify();//   ODFACT_NANDFlash();
         return FALSE;
#endif


        /* initialize zone table position infomation */
        MEMSET(NandDevInfo.ZoneInfo, 0xff, (NAND_MAX_DIE_NUM * MAX_ZONE_NUM_IN_DIE) * sizeof(struct ZoneInfoType));

        for (DieNo = 0; DieNo < DIENUM_IN_FLASH; DieNo++)
        {
                MEMSET(sdi, 0x0, sizeof(struct ScanDieInfo));
                sdi->DieNo = DieNo;

                ret = ScanSearchZoneTbls(sdi);
//return FALSE;
#if   _TEST_HW_PageCTL_ ==0x01				
		return FALSE;
#endif
                //DbgScanCheckZoneTbl(sdi);

                if (ret != TRUE)
                {
retry:
                        ret = ScanRebuildZoneTbls(sdi);
                        if (ret == SCAN_ERR_TRY_AGAIN)
                        {
                                DMSG(DBL_LOG, "[INIT] ScanRebuildZoneTbls() try again(dieno: %u).\n", DieNo);
                                goto retry;
                        }
                        else if (ret != TRUE)
                        {
                                DMSG(DBL_ERR, "[INIT] INIT_CreateBlkTbls(dieno: %u) error, ret %u\n", DieNo, ret);
                                break;
                        }
                }
        }

failed:
        DMSG(DBL_LOG, "[INIT] INIT_CreateBlkTbls() out, ret %d.\n", ret);
        if (GPageBuf)
        {
                FREE(GPageBuf);
        }
	if (NandDevInfo.PhyCache)
        {
                FREE(NandDevInfo.PhyCache);
        }
	if (NandDevInfo.TestBuf)
        {
                FREE(NandDevInfo.TestBuf);
        }
        return ret;
}
